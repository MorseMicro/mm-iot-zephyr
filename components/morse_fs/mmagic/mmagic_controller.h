/*
 * Copyright 2025 Morse Micro
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Warning: this file is autogenerated. Do not modify by hand.
 */

#pragma once

/**
 * @ingroup MMAGIC
 * @defgroup MMAGIC_CONTROLLER Morse M2M Interface Controller API
 *
 * @{
 *
 * This module provides a small implementation of the Controller stack for integration with
 * application software. This code mostly stands alone from the rest of the Morse IoT SDK.
 *
 * To integrate the Controller code into your application:
 * * Copy the files in this directory into your application.
 * * Also copy `mmutils/mmutils.h`, `mmutils/mmbuf.h`, and `mmutils/mmbuf.c` into your application.
 * * Implement the APIs defined by `mmagic_datalink_controller.h` and `mmosal_controller.h`. (See
 *   the @c m2m_controller.c application as a reference.)
 * * Include mmagic_controller.h in your application to integrate the Controller functionality.
 */

#include <stdbool.h>
#include <stddef.h>
#include <memory.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MM_PACKED
/** Macro for packed structs */
#define MM_PACKED __attribute__((packed))
#endif

/**
 * @defgroup MMAGIC_CONTROLLER_DATA_TYPES Data types
 *
 * @{
 */

/** Connection security type. */
enum mmagic_security_type
{
    /** Simultaneous Authentication of Equals (password-based authentication). */
    MMAGIC_SECURITY_TYPE_SAE  = 0,
    /** Opportunistic Wireless Encryption (encrypted, passwordless). */
    MMAGIC_SECURITY_TYPE_OWE  = 1,
    /** No security enabled at all. */
    MMAGIC_SECURITY_TYPE_OPEN = 2,
};

/** Protected management frame mode. */
enum mmagic_pmf_mode
{
    /** Protected management frames must be used. */
    MMAGIC_PMF_MODE_REQUIRED = 0,
    /** No protected management frames. */
    MMAGIC_PMF_MODE_DISABLED = 1,
};

/** Enumeration of supported 802.11 power save modes. */
enum mmagic_power_save_mode
{
    /** Power save disabled. */
    MMAGIC_POWER_SAVE_MODE_DISABLED = 0,
    /** Power save enabled. */
    MMAGIC_POWER_SAVE_MODE_ENABLED  = 1,
};

/** Enumeration of MCS10 modes. */
enum mmagic_mcs10_mode
{
    /** MCS10 is not used. */
    MMAGIC_MCS10_MODE_DISABLED = 0,
    /** MCS10 is always used instead of MCS0 when the bandwidth is 1 MHz. */
    MMAGIC_MCS10_MODE_FORCED   = 1,
    /** MCS10 is used on retries instead of MCS0 when the bandwidth is 1 MHz. */
    MMAGIC_MCS10_MODE_AUTO     = 2,
};

/** Enumeration of duty cycle modes. */
enum mmagic_duty_cycle_mode
{
    /** Duty cycle air time is evenly spread. */
    MMAGIC_DUTY_CYCLE_MODE_SPREAD = 0,
    /** Duty cycle air time available in burst. */
    MMAGIC_DUTY_CYCLE_MODE_BURST  = 1,
};

/** Enumeration of S1G non-AP STA types. */
enum mmagic_station_type
{
    /** Sensor type. */
    MMAGIC_STATION_TYPE_SENSOR     = 0,
    /** Non-Sensor type. */
    MMAGIC_STATION_TYPE_NON_SENSOR = 1,
};

/** Enumeration of return status codes. */
enum mmagic_status
{
    /** Operation was successful. */
    MMAGIC_STATUS_OK                       = 0,
    /** The operation failed with an unspecified error. */
    MMAGIC_STATUS_ERROR                    = 1,
    /** The operation failed due to an invalid argument. */
    MMAGIC_STATUS_INVALID_ARG              = 2,
    /** Functionality is temporarily unavailable. */
    MMAGIC_STATUS_UNAVAILABLE              = 3,
    /** The operation timed out. */
    MMAGIC_STATUS_TIMEOUT                  = 4,
    /** An invalid stream was specified. */
    MMAGIC_STATUS_INVALID_STREAM           = 5,
    /** Specified operation was not found. */
    MMAGIC_STATUS_NOT_FOUND                = 6,
    /** Specified operation is not supported. */
    MMAGIC_STATUS_NOT_SUPPORTED            = 7,
    /** An error occured during transmission. */
    MMAGIC_STATUS_TX_ERROR                 = 8,
    /** Failed due to memory allocation failure. */
    MMAGIC_STATUS_NO_MEM                   = 9,
    /** Failed due to stream being closed from the other side. */
    MMAGIC_STATUS_CLOSED                   = 10,
    /** WLAN operation failed because the channel list has not been set. */
    MMAGIC_STATUS_CHANNEL_LIST_NOT_SET     = 11,
    /** WLAN shutdown failed. */
    MMAGIC_STATUS_SHUTDOWN_BLOCKED         = 12,
    /** Attempted to tune to a channel that was not available. */
    MMAGIC_STATUS_CHANNEL_INVALID          = 13,
    /** Operation failed because the WLAN device was not booted. */
    MMAGIC_STATUS_NOT_RUNNING              = 14,
    /** Operation failed because the link was not up. */
    MMAGIC_STATUS_NO_LINK                  = 15,
    /** Failed to get an IP address for the given hostname. */
    MMAGIC_STATUS_UNKNOWN_HOST             = 16,
    /** Failed to open the socket. */
    MMAGIC_STATUS_SOCKET_FAILED            = 17,
    /** Socket connection failed. */
    MMAGIC_STATUS_SOCKET_CONNECT_FAILED    = 18,
    /** Socket bind failed. */
    MMAGIC_STATUS_SOCKET_BIND_FAILED       = 19,
    /** Socket listen failed. */
    MMAGIC_STATUS_SOCKET_LISTEN_FAILED     = 20,
    /** NTP server returned Kiss-o'-Death. */
    MMAGIC_STATUS_NTP_KOD_RECEIVED         = 21,
    /** NTP server returned Kiss-o'-Death with rate code. Client should backoff then retry. */
    MMAGIC_STATUS_NTP_KOD_BACKOFF_RECEIVED = 22,
    /** Socket send failed. */
    MMAGIC_STATUS_SOCKET_SEND_FAILED       = 23,
    /** Credentials provided were invalid. Possible cause: missing null terminator on a PEM
     * key/certificate. */
    MMAGIC_STATUS_INVALID_CREDENTIALS      = 24,
    /** Error during TLS handshake. */
    MMAGIC_STATUS_HANDSHAKE_FAILED         = 25,
    /** Credentials provided by the server were not valid. */
    MMAGIC_STATUS_AUTHENTICATION_FAILED    = 26,
    /** Missing certificate or key to open TLS connection. Provided through the TLS module
     * configuration. */
    MMAGIC_STATUS_MISSING_CREDENTIALS      = 27,
    /** Internal time has not been synchronized. This is required for certificate verification for
     * TLS. Use the NTP module to synchronize internal time. */
    MMAGIC_STATUS_TIME_NOT_SYNCHRONIZED    = 28,
    /** The server refused a CONNECT or SUBSCRIBE. */
    MMAGIC_STATUS_MQTT_REFUSED             = 29,
    /** Timed out while waiting for PINGRESP. Connection to the broker has been lost. */
    MMAGIC_STATUS_MQTT_KEEPALIVE_TIMEOUT   = 30,
    /** Operation failed due to a version mismatch. */
    MMAGIC_STATUS_BAD_VERSION              = 32,
};

/** Mode to use when running the iperf. */
enum mmagic_iperf_mode
{
    /** Iperf UDP server (RX). */
    MMAGIC_IPERF_MODE_UDP_SERVER = 0,
    /** Iperf TCP server (RX). */
    MMAGIC_IPERF_MODE_TCP_SERVER = 1,
    /** Iperf UDP client (TX). */
    MMAGIC_IPERF_MODE_UDP_CLIENT = 2,
    /** Iperf TCP client (TX). */
    MMAGIC_IPERF_MODE_TCP_CLIENT = 3,
};

/** Current state of iperf session. */
enum mmagic_iperf_state
{
    /** Iperf session not started. */
    MMAGIC_IPERF_STATE_NOT_STARTED = 0,
    /** Iperf session is in progress. */
    MMAGIC_IPERF_STATE_RUNNING     = 1,
    /** Iperf session has completed. */
    MMAGIC_IPERF_STATE_FINISHED    = 2,
    /** Iperf session has been aborted. */
    MMAGIC_IPERF_STATE_ABORTED     = 3,
};

/** Status of the IP link. */
enum mmagic_ip_link_state
{
    /** Link is down because the interface is down or DHCP has not yet completed. */
    MMAGIC_IP_LINK_STATE_DOWN = 0,
    /** Link is up. This implies that the interface is up and DHCP has completed. */
    MMAGIC_IP_LINK_STATE_UP   = 1,
};

/** Deep sleep modes for the agent MCU. */
enum mmagic_deep_sleep_mode
{
    /** Deep sleep is disabled. */
    MMAGIC_DEEP_SLEEP_MODE_DISABLED = 0,
    /** Deep sleep is enabled until activity occurs on the datalink. */
    MMAGIC_DEEP_SLEEP_MODE_ONE_SHOT = 1,
    /** The datalink layer is responsible for waking the agent. */
    MMAGIC_DEEP_SLEEP_MODE_HARDWARE = 2,
};

/** Reasons for exiting standby mode. */
enum mmagic_standby_mode_exit_reason
{
    /** Standby mode was exited manually through a call to standby_exit. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_NONE                    = 0,
    /** We were woken up by a wakeup frame. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WAKEUP_FRAME            = 1,
    /** We just reassociated with the AP. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_ASSOCIATE               = 2,
    /** We were woken up by an external input trigger. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_EXT_INPUT               = 3,
    /** We received a packet from a whitelist source. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_WHITELIST_PKT           = 4,
    /** An open TCP connection was lost. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_TCP_CONNECTION_LOST     = 5,
    /** Hardware scan was not enabled. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_HW_SCAN_NOT_ENABLED     = 6,
    /** Hardware scan failed to start. */
    MMAGIC_STANDBY_MODE_EXIT_REASON_STANDBY_EXIT_HW_SCAN_FAILED_TO_START = 7,
};

/** Station states */
enum mmagic_sta_state
{
    /** Disconnected from the AP. */
    MMAGIC_STA_STATE_DISCONNECTED = 1,
    /** Connecting to the AP. */
    MMAGIC_STA_STATE_CONNECTING   = 2,
    /** Connected to the AP. */
    MMAGIC_STA_STATE_CONNECTED    = 3,
};

/** Station connection events. */
enum mmagic_sta_event
{
    /** The STA is starting a scan. */
    MMAGIC_STA_EVENT_SCAN_REQUEST     = 0,
    /** The STA has finished a scan. */
    MMAGIC_STA_EVENT_SCAN_COMPLETE    = 1,
    /** The STA has aborted a scan early. */
    MMAGIC_STA_EVENT_SCAN_ABORT       = 2,
    /** The STA is sending an authentication request to the AP. */
    MMAGIC_STA_EVENT_AUTH_REQUEST     = 3,
    /** The STA is sending an association request to the AP. */
    MMAGIC_STA_EVENT_ASSOC_REQUEST    = 4,
    /** The STA is sending an de-authorization request to the AP. */
    MMAGIC_STA_EVENT_DEAUTH_TX        = 5,
    /** The Supplicant IEEE 802.1X Controlled Port is now open. */
    MMAGIC_STA_EVENT_CTRL_PORT_OPEN   = 6,
    /** The Supplicant IEEE 802.1X Controlled Port is now closed. */
    MMAGIC_STA_EVENT_CTRL_PORT_CLOSED = 7,
};

/** String type with maximum length of 32 (excluding null terminator). */
struct MM_PACKED string32
{
    /** Length of string contents (excluding null terminator). */
    uint8_t len;

    /** The string contents. */
    char data[32 + 1];
};

/** String type with maximum length of 100 (excluding null terminator). */
struct MM_PACKED string100
{
    /** Length of string contents (excluding null terminator). */
    uint8_t len;

    /** The string contents. */
    char data[100 + 1];
};

/** String type with maximum length of 254 (excluding null terminator). */
struct MM_PACKED string254
{
    /** Length of string contents (excluding null terminator). */
    uint8_t len;

    /** The string contents. */
    char data[254 + 1];
};

/** Raw octet string type with maximum length of 255. */
struct MM_PACKED raw255
{
    /** Length of @c data. */
    uint8_t len;

    /** The acutal data buffer. */
    uint8_t data[255];
};

/** Raw octet string type with maximum length of 1536. */
struct MM_PACKED raw1536
{
    /** Length of @c data. */
    uint16_t len;

    /** The acutal data buffer. */
    uint8_t data[1536];
};

/** Data type to contain mac address byte array. */
struct MM_PACKED struct_mac_addr
{
    /** Array containing the mac addr. */
    uint8_t addr[6];
};

/** Data type to contain Two character country code (null-terminated) used to identify the
 * regulatory domain. */
struct MM_PACKED struct_country_code
{
    /** Array containing the country code, including room for null-terminator. */
    char country_code[3];
};

/** Data type to contain a three octet OUI. */
struct MM_PACKED struct_oui
{
    /** The 3 octet OUI. */
    uint8_t oui[3];
};

/** Data type to contain a list of three octet OUIs. */
struct MM_PACKED struct_oui_list
{
    /** The number of OUIs in the list. */
    uint8_t count;
    /** The OUI data. */
    struct struct_oui ouis[5];
};

/** Structure for holding a scan result. */
struct MM_PACKED struct_scan_result
{
    /** SSID of the AP. */
    struct string32 ssid;
    /** BSSID of the AP network. */
    struct struct_mac_addr bssid;
    /** RSSI of the AP in dBm. */
    int32_t rssi;
    /** Pointer to the start of the Information Elements within the Probe Response frame. */
    struct raw255 ies;
    /** Length of the ies field in the received frame. May exceed the size of the ies buffer in this
     * structure. */
    uint16_t received_ies_len;
    /** Value of the Beacon Interval field. */
    uint16_t beacon_interval;
    /** Value of the Capability Information field. */
    uint16_t capability_info;
    /** Center frequency in Hz of the channel where the frame was received. */
    uint32_t channel_freq_hz;
    /** Bandwidth, in MHz, where the frame was received. */
    uint8_t bw_mhz;
    /** Operating bandwidth, in MHz, of the access point. */
    uint8_t op_bw_mhz;
    /** TSF timestamp in the Probe Response frame. */
    uint64_t tsf;
};

/** Structure for devise firmware and hardware versions. */
struct MM_PACKED struct_version_info
{
    /** Version of the application software. */
    struct string32 application_version;
    /** Version of the bootloader software. */
    struct string32 bootloader_version;
    /** Version of the user hardware. */
    struct string32 user_hardware_version;
    /** Version of the Morse firmware. */
    struct string32 morse_firmware_version;
    /** Version of the Morse IoT SDK library. */
    struct string32 morselib_version;
    /** Version of the Morse hardware. */
    struct string32 morse_hardware_version;
};

/** Structure for returning the scan status. */
struct MM_PACKED struct_scan_status
{
    /** Array of scan results. */
    struct struct_scan_result results[10];
    /** Number of results retrieved. */
    uint8_t num;
};

/** Data type for a string representation of an IP address. Dotted decimal notation for IPv4
 * addresses and colon-separated hexadecimal notation for IPv6 addresses. */
struct MM_PACKED struct_ip_addr
{
    /** Array containing the IP string. */
    char addr[48];
};

/** Structure to contain the current IP status. */
struct MM_PACKED struct_ip_status
{
    /** Current link state. */
    enum mmagic_ip_link_state link_state;
    /** Whether or not dhcp is enabled. */
    bool dhcp_enabled;
    /** Current IP address. */
    struct struct_ip_addr ip_addr;
    /** Current IP network mask. */
    struct struct_ip_addr netmask;
    /** Current IP gateway. */
    struct struct_ip_addr gateway;
    /** Current broadcast IP address. */
    struct struct_ip_addr broadcast;
    /** DNS server IP addresses. */
    struct struct_ip_addr dns_servers[2];
};

/** Data structure to store ping results. */
struct MM_PACKED struct_ping_status
{
    /** IP address of the device receiving the ping requests. */
    struct struct_ip_addr receiver_addr;
    /** Total number of requests sent. */
    uint32_t total_count;
    /** The number of ping responses received. */
    uint32_t recv_count;
    /** The minimum latency in ms between request sent and response received. */
    uint32_t min_time_ms;
    /** The average latency in ms between request sent and response received. */
    uint32_t avg_time_ms;
    /** The maximum latency in ms between request sent and response received. */
    uint32_t max_time_ms;
    /** Stores non-zero session ID whilst ping session is running. */
    uint16_t session_id;
};

/** Data structure to store iperf results. */
struct MM_PACKED struct_iperf_status
{
    /** IP address of the remote device. */
    struct struct_ip_addr remote_addr;
    /** Port number of the remote device. */
    uint16_t remote_port;
    /** IP address of the local device. */
    struct struct_ip_addr local_addr;
    /** Port number of the local device. */
    uint16_t local_port;
    /** The number of bytes of data transferred during the iperf test. */
    uint64_t bytes_transferred;
    /** The duration of the iperf test in milliseconds. */
    uint32_t duration_ms;
    /** The average throughput in kbps. */
    uint32_t bandwidth_kbitpsec;
};

/** Generic 64 byte buffer. */
struct MM_PACKED struct_buffer64
{
    /** The 64 byte buffer. */
    uint8_t buffer[64];
    /** Length of data in the buffer. */
    uint8_t len;
};

/**
 * Subsytem IDs
 */
enum mmagic_subsystem
{
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_WLAN */
    MMAGIC_WLAN  = 1,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_IP */
    MMAGIC_IP    = 2,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_PING */
    MMAGIC_PING  = 3,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_IPERF */
    MMAGIC_IPERF = 4,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_SYS */
    MMAGIC_SYS   = 5,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_TCP */
    MMAGIC_TCP   = 6,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_TLS */
    MMAGIC_TLS   = 7,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_NTP */
    MMAGIC_NTP   = 8,
    /** Subsystem ID for @ref MMAGIC_CONTROLLER_MQTT */
    MMAGIC_MQTT  = 9,
};

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_INIT Initialization/deinitialization
 * @{
 */

/**
 * Controller struct used internally by the data-link. This will be specific to each
 * type of controller. i.e SPI and UART may have different elements in the struct.
 */
struct mmagic_controller;

/**
 * Prototype for callback function invoked whenever any time a event that the agent has
 * started is received.
 *
 * @note This callback will execute in the context of the Controller data link receive thread.
 *
 * @param controller Reference to the the controller handle.
 * @param arg        User argument that was given when the callback was registered.
 */
typedef void (*mmagic_controller_agent_start_cb_t)(struct mmagic_controller *controller, void *arg);

/**
 * Initialization structure for mmagic_controller.
 */
struct mmagic_controller_init_args
{
    /** Callback function to executed any time a event that the agent has started is received. */
    mmagic_controller_agent_start_cb_t agent_start_cb;
    /** User argument that will be passed when the agent_start_cb is executed. */
    void *agent_start_arg;
};

/**
 * Initializer for @ref mmagic_controller_init_args.
 */
#define MMAGIC_CONTROLLER_ARGS_INIT { 0 }

/**
 * Initialize the Controller.
 *
 * @param  args Reference to the initialization arguments for the mmagic_controller.
 *              May be @c NULL, in which case default values will be used.
 *
 * @return      Reference to the created controller handle on success. @c Null on error.
 */
struct mmagic_controller *mmagic_controller_init(const struct mmagic_controller_init_args *args);

/**
 * Deinitialize the Controller. Any resources used will be freed.
 *
 * @param controller Reference to the controller handle.
 */
void mmagic_controller_deinit(struct mmagic_controller *controller);

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_INTERNAL Data types, etc., for internal use
 * @{
 *
 * Enumerations, etc., used by the underlying implementation, but which are not usually
 * needed to be used directly.
 */

/** The stream ID of the control stream */
#define CONTROL_STREAM  0

/** The default timeout when waiting for a response from a command sent to the agent in ms. */
#define MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS 1000

/**
 * Sends a command to the agent.
 *
 * @param  controller    A user context to be passed.
 * @param  stream_id     The stream id to send this command on.
 * @param  submodule_id  The submodule to target with this command.
 * @param  command_id    The command.
 * @param  subcommand_id A sub command or resource id if applicable.
 * @param  buffer        A pointer to any data associated with this command.
 *                       May be NULL if none.
 * @param  buffer_length Length of above data.
 *
 * @return               MMAGIC_STATUS_OK on success, else an error code.
 */
enum mmagic_status mmagic_controller_tx(
    struct mmagic_controller *controller, uint8_t stream_id,
    uint8_t submodule_id, uint8_t command_id, uint8_t subcommand_id,
    const uint8_t *buffer, size_t buffer_length);

/**
 * Waits for a response from the agent.
 *
 * @param  controller    Controller context.
 * @param  stream_id     The stream id to wait on.
 * @param  submodule_id  The submodule to wait on.
 * @param  command_id    The command to wait on.
 * @param  subcommand_id A sub command or resource id if applicable.
 * @param  buffer        A pointer to a buffer to load with any returned data.
 *                       May be NULL if none.
 * @param  buffer_length Length of above buffer.
 * @param  timeout_ms    The time in milliseconds to wait for a response from the agent,
 *                       set to @c UINT32_MAX for an indefinite wait.
 *
 * @return               MMAGIC_STATUS_OK on success, else an error code.
 */
enum mmagic_status mmagic_controller_rx(struct mmagic_controller *controller, uint8_t stream_id,
                                        uint8_t submodule_id,
                                        uint8_t command_id, uint8_t subcommand_id,
                                        uint8_t *buffer, size_t buffer_length, uint32_t timeout_ms);

/**
 * Sends a sync request to the agent and waits for a sync response.
 *
 * This function will block waiting for a response from the agent or until the provided timeout
 * duration elapses.
 *
 * @param  controller Controller context.
 * @param  timeout_ms Duration to wait for a sync response from the agent.
 *
 * @return            MMAGIC_STATUS_OK on successful sync, else an appropriate error code.
 */
enum mmagic_status mmagic_controller_agent_sync(struct mmagic_controller *controller,
                                                uint32_t timeout_ms);

/**
 * Sends a reset request to the agent.
 *
 * A reset is considered successful when the agent returns a start notification. On success, the
 * controller @c agent_start_cb function will be executed.
 *
 * @note This function will return once a reset request has been transmitted. It is up to the
 * application to handle waiting for the start callback to be called.
 *
 * @note Both this function and @ref mmagic_controller_sys_reset will perform a soft reset of the
 * agent, however this function should be preferred as the reset is handled at a lower layer in the
 * agents MMAGIC stack.
 *
 * @param  controller Controller context.
 *
 * @return            MMAGIC_STATUS_OK on successful transmission, else an error code.
 */
enum mmagic_status mmagic_controller_request_agent_reset(struct mmagic_controller *controller);

/** wlan configuration variable IDs */
enum mmagic_wlan_var
{
    /** Two character country code used to identify the regulatory domain. */
    MMAGIC_WLAN_VAR_COUNTRY_CODE              = 0,
    /** SSID of the AP to connect to, can be 1-32 characters long. */
    MMAGIC_WLAN_VAR_SSID                      = 1,
    /** Password used when associating, 1-100 characters long. */
    MMAGIC_WLAN_VAR_PASSWORD                  = 2,
    /** Security type to used when associating. */
    MMAGIC_WLAN_VAR_SECURITY                  = 3,
    /** Priority to request if raw is supported by the AP. Valid priorities are 0-7. -1 disables
     * RAW. */
    MMAGIC_WLAN_VAR_RAW_PRIORITY              = 4,
    /** BSSID of the ap to associate to, all 0x00 for any. */
    MMAGIC_WLAN_VAR_BSSID                     = 5,
    /** Protected Management Frame mode to use (802.11w). */
    MMAGIC_WLAN_VAR_PMF_MODE                  = 6,
    /** S1G non-AP STA type. */
    MMAGIC_WLAN_VAR_STATION_TYPE              = 7,
    /** The RTS threshold (in octets) to set, or 0 to disable. */
    MMAGIC_WLAN_VAR_RTS_THRESHOLD             = 8,
    /** Boolean value indicating whether SGI support should be enabled. */
    MMAGIC_WLAN_VAR_SGI_ENABLED               = 9,
    /** Boolean value indicating whether sub-band support should be enabled. */
    MMAGIC_WLAN_VAR_SUBBANDS_ENABLED          = 10,
    /** Boolean value indicating whether AMPDU support should be enabled. */
    MMAGIC_WLAN_VAR_AMPDU_ENABLED             = 11,
    /** Sets the 802.11 power save mode. */
    MMAGIC_WLAN_VAR_POWER_SAVE_MODE           = 12,
    /** Sets the 802.11 fragmentation threshold. The fragmentation threshold (in octets) to set, or
     * 0 to disable. */
    MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD        = 13,
    /** Whether Centralized Authentication Controlled is enabled on the STA. */
    MMAGIC_WLAN_VAR_CAC_ENABLED               = 14,
    /** If true, enables ARP response offload which allows the Morse chip to directly respond to ARP
     * requests without waking up the host processor. */
    MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE      = 15,
    /** If non zero, enables ARP refresh offload with the specified interval in seconds. Note: ARP
     * response offload needs to be enabled for this feature to work. */
    MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S     = 16,
    /** The minimum interval to wait after the last health check before triggering another. If this
     * parameter is 0 then health checks will always happen at the max_interval_ms value.
     * min_interval_ms must always be less than or equal to max_interval_ms. If only
     * min_health_check_intvl_ms is specified, then max_health_check_intvl_ms is assumed to be
     * unbounded. */
    MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS = 17,
    /** The maximum interval to wait after the last health check before triggering another. If this
     * parameter is 0 then periodic health checks will be disabled. min_interval_ms must always be
     * less than or equal to max_interval_ms. Set this to UINT32_MAX to have the maximum unbounded.
     * If only max_health_check_intvl_ms is specified, then min_health_check_intvl_ms is assumed to
     * be 0. */
    MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS = 18,
    /** Boolean value indicating whether NDP probe support should be enabled. Will only take effect
     * after a connect or scan command is sent. */
    MMAGIC_WLAN_VAR_NDP_PROBE_ENABLED         = 19,
    /** The base scan interval (in seconds) to use when (re)connecting. See documentation of
     * mmwlan_sta_args.scan_interval_base_s for further details. Note that changes will only take
     * effect on invocation of wlan-connect. */
    MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_BASE_S  = 20,
    /** The maximum interval between scan attempts when (re)connecting. See documentation of
     * mmwlan_sta_args.scan_interval_limit_s for further details. Note that changes will only take
     * effect on invocation of wlan-connect. */
    MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_LIMIT_S = 21,
    /** The default QoS queue configuration for Access Category 0 (AC_BE) that is active while the
     * station is connecting to an Access Point. This is a string containing the following comma
     * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
     * `3,15,1023,15008`. More information about the individual parameters can be found in the API
     * documentation for `mmwlan_qos_queue_params`. */
    MMAGIC_WLAN_VAR_QOS_0_PARAMS              = 22,
    /** The default QoS queue configuration for Access Category 1 (AC_BK) that is active while the
     * station is connecting to an Access Point. This is a string containing the following comma
     * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
     * `7,15,1023,15008`. More information about the individual parameters can be found in the API
     * documentation for `mmwlan_qos_queue_params`. */
    MMAGIC_WLAN_VAR_QOS_1_PARAMS              = 23,
    /** The default QoS queue configuration for Access Category 2 (AC_VI) that is active while the
     * station is connecting to an Access Point. This is a string containing the following comma
     * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
     * `2,7,15,15008`. More information about the individual parameters can be found in the API
     * documentation for `mmwlan_qos_queue_params`. */
    MMAGIC_WLAN_VAR_QOS_2_PARAMS              = 24,
    /** The default QoS queue configuration for Access Category 3 (AC_VO) that is active while the
     * station is connecting to an Access Point. This is a string containing the following comma
     * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
     * `2,3,7,15008`. More information about the individual parameters can be found in the API
     * documentation for `mmwlan_qos_queue_params`. */
    MMAGIC_WLAN_VAR_QOS_3_PARAMS              = 25,
    /** The currently configured MCS10 behavior. This only takes effect after calling the WLAN
     * connect command. This is an enum with 3 modes: disabled, which will never use MCS10, forced,
     * which will always use MCS10 instead of MCS0 if the bandwidth is 1 MHz, and auto, which will
     * use MCS10 on retries instead of MCS0 when the bandwidth is 1 MHz. */
    MMAGIC_WLAN_VAR_MCS10_MODE                = 26,
    /** When set to true, STA event notifications will be provided. Setting this to false will
     * suppress these notifications. Defaults to false. */
    MMAGIC_WLAN_VAR_STA_EVT_EN                = 27,
    /** The duty cycle air time distribution mode. The duty cycle mode can be set to spread, where
     * the air time is spread evenly across the window; or burst, where air time is available to be
     * consumed immediately. */
    MMAGIC_WLAN_VAR_DUTY_CYCLE_MODE           = 28,
};

/** wlan configuration command IDs */
enum mmagic_wlan_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_WLAN_CMD_GET                        = 0,
    /** Set the value of a configuration variable */
    MMAGIC_WLAN_CMD_SET                        = 1,
    /** Reserved (unused) */
    MMAGIC_WLAN_CMD_LOAD                       = 2,
    /** Commit the current configuration to flash */
    MMAGIC_WLAN_CMD_COMMIT                     = 3,
    /** Brings up the WLAN interface and connects to the AP with configured parameters. */
    MMAGIC_WLAN_CMD_CONNECT                    = 8,
    /** Disconnects and brings down the WLAN interface. */
    MMAGIC_WLAN_CMD_DISCONNECT                 = 9,
    /** Starts an undirected scan for available networks. */
    MMAGIC_WLAN_CMD_SCAN                       = 10,
    /** Retrieves the RSSI if the WLAN interface is up, else 0. */
    MMAGIC_WLAN_CMD_GET_RSSI                   = 11,
    /** Retrieves the MAC address if the WLAN interface is up. */
    MMAGIC_WLAN_CMD_GET_MAC_ADDR               = 12,
    /** Requests entry or exit from extended sleep (wnm sleep) if the WLAN interface is up. */
    MMAGIC_WLAN_CMD_WNM_SLEEP                  = 13,
    /** Enable beacon monitoring with the given filter settings. If beacon monitoring is already
     * enabled it will be reconfigured with the given arguments. */
    MMAGIC_WLAN_CMD_BEACON_MONITOR_ENABLE      = 14,
    /** Disable beacon monitoring. If beacon monitor is not enabled then this has no effect. */
    MMAGIC_WLAN_CMD_BEACON_MONITOR_DISABLE     = 15,
    /** This puts the Morse chip into standby mode allowing the host processor to go to sleep while
     * the Morse chip takes over certain functionality to keep the connection alive with the
     * provision to wake up the host processor when certain conditions are met. */
    MMAGIC_WLAN_CMD_STANDBY_ENTER              = 16,
    /** Forces the Morse chip to exit standby mode. There may be certain instances such as a timer
     * expiry, which cause the host chip to wake up independant of the Morse chip. In such
     * situations, the host calls this function to instruct the Morse chip to exit standby mode and
     * return to normal operating mode. */
    MMAGIC_WLAN_CMD_STANDBY_EXIT               = 17,
    /** Sets the user payload for the standby status packet. Once standby mode is enabled, the Morse
     * chip will periodically emit a UDP standby status packet regardless of whether it is in
     * standby or not. The UDP packet will also be sent immediately upon entering or exiting Standby
     * mode. If this command is not executed then the standby status packet will contain no payload.
     */
    MMAGIC_WLAN_CMD_STANDBY_SET_STATUS_PAYLOAD = 18,
    /** Configures the standby mode UDP wake packet filter. The system can be woken up from standby
     * mode by sending it a UDP wake packet. If a wake filter is set using this function then the
     * wake packet will only wake up the system if the specified filter pattern matches the payload
     * at the specified offset within the payload. If this command is not executed then any wake
     * packet will wake up the system. */
    MMAGIC_WLAN_CMD_STANDBY_SET_WAKE_FILTER    = 19,
    /** Sets the standby mode configuration parameters. If this command is not executed then the
     * defaults are as specified. */
    MMAGIC_WLAN_CMD_STANDBY_SET_CONFIG         = 20,
    /** Retrieves the STA status of the WLAN interface. */
    MMAGIC_WLAN_CMD_GET_STA_STATUS             = 21,
};

/** ip configuration variable IDs */
enum mmagic_ip_var
{
    /** IP address to use for a static network connection. This will take effect when the reload
     * command is successfully executed. */
    MMAGIC_IP_VAR_IP_ADDR            = 0,
    /** Netmask to use for a static network connection. This will take effect when the reload
     * command is successfully executed. */
    MMAGIC_IP_VAR_NETMASK            = 1,
    /** Gateway to use for a static network connection. This will take effect when the reload
     * command is successfully executed. */
    MMAGIC_IP_VAR_GATEWAY            = 2,
    /** Primary DNS server IP address. If a value is specified this will override the primary DNS
     * server provided by DHCP (if any). Changes will take effect when the reload command is
     * successfully executed. */
    MMAGIC_IP_VAR_DNS_SERVER0        = 3,
    /** Secondary DNS server IP address. If a value is specified this will override the secondary
     * DNS server provided by DHCP (if any). Changes will take effect when the reload command is
     * successfully executed. Note that this option may be ignored by some IP stacks. */
    MMAGIC_IP_VAR_DNS_SERVER1        = 4,
    /** True to enable DHCP for IP address configuration, or false to use the static configuration
     * given by ip_addr, netmask, and gateway. This will take effect when the reload command is
     * successfully executed. */
    MMAGIC_IP_VAR_DHCP_ENABLED       = 5,
    /** If true, enables DHCP offload which allows the Morse chip to directly handle DHCP discovery
     * and leases without waking up the host processor. Note: this comes into effect only if
     * ip.dhcp_enabled is also true. */
    MMAGIC_IP_VAR_DHCP_OFFLOAD       = 6,
    /** When set to true, IP link status notifications will be provided. Setting this to false will
     * suppress these notifications. Defaults to true. */
    MMAGIC_IP_VAR_LINK_STATUS_EVT_EN = 7,
};

/** ip configuration command IDs */
enum mmagic_ip_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_IP_CMD_GET                           = 0,
    /** Set the value of a configuration variable */
    MMAGIC_IP_CMD_SET                           = 1,
    /** Reserved (unused) */
    MMAGIC_IP_CMD_LOAD                          = 2,
    /** Commit the current configuration to flash */
    MMAGIC_IP_CMD_COMMIT                        = 3,
    /** Gets the status of the IP stack. */
    MMAGIC_IP_CMD_STATUS                        = 8,
    /** Reloads the IP stack network configuration based on the current values in the subsystem
     * config. */
    MMAGIC_IP_CMD_RELOAD                        = 9,
    /** Enables sending periodic TCP keep-alive packets by the morse chip allowing the TCP
     * connection to be maintained without waking up the host processor. This needs to be enabled
     * before opening a TCP connection. As of now, this feature will work only on the first TCP
     * connection opened after this command. */
    MMAGIC_IP_CMD_ENABLE_TCP_KEEPALIVE_OFFLOAD  = 10,
    /** Disables sending of TCP keepalive packets. */
    MMAGIC_IP_CMD_DISABLE_TCP_KEEPALIVE_OFFLOAD = 11,
    /** Sets the whitelist filter specifing which incoming packets can wake the system from standby
     * mode. */
    MMAGIC_IP_CMD_SET_WHITELIST_FILTER          = 12,
    /** Clears any applied whitelist filters. */
    MMAGIC_IP_CMD_CLEAR_WHITELIST_FILTER        = 13,
};

/** ping configuration variable IDs */
enum mmagic_ping_var
{
    /** The IP address of the ping target. */
    MMAGIC_PING_VAR_TARGET   = 0,
    /** The time interval between ping requests (in milliseconds). */
    MMAGIC_PING_VAR_INTERVAL = 1,
    /** This specifies the number of ping requests to send before terminating the session. If this
     * is zero or exceeds UINT16_MAX (65535) then it it will be set to UINT16_MAX. */
    MMAGIC_PING_VAR_COUNT    = 2,
};

/** ping configuration command IDs */
enum mmagic_ping_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_PING_CMD_GET    = 0,
    /** Set the value of a configuration variable */
    MMAGIC_PING_CMD_SET    = 1,
    /** Reserved (unused) */
    MMAGIC_PING_CMD_LOAD   = 2,
    /** Commit the current configuration to flash */
    MMAGIC_PING_CMD_COMMIT = 3,
    /** Commences a ping session using the current values in the the subsystem config. */
    MMAGIC_PING_CMD_RUN    = 8,
};

/** iperf configuration variable IDs */
enum mmagic_iperf_var
{
    /** The iperf mode to use. Valid values are udp_server, tcp_server, udp_client and tcp_client.
     * If not set, defaults to udp_server. */
    MMAGIC_IPERF_VAR_MODE   = 0,
    /** IP address of server to connect to when in client mode. */
    MMAGIC_IPERF_VAR_SERVER = 1,
    /** Specifies the local port to listen on when in server mode or the server port to send data to
     * when in client mode. */
    MMAGIC_IPERF_VAR_PORT   = 2,
    /** This specifies the duration for client transfers specified either in seconds or bytes. If
     * this is negative, it specifies a time in seconds; if positive, it specifies the number of
     * bytes to transmit. */
    MMAGIC_IPERF_VAR_AMOUNT = 3,
};

/** iperf configuration command IDs */
enum mmagic_iperf_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_IPERF_CMD_GET    = 0,
    /** Set the value of a configuration variable */
    MMAGIC_IPERF_CMD_SET    = 1,
    /** Reserved (unused) */
    MMAGIC_IPERF_CMD_LOAD   = 2,
    /** Commit the current configuration to flash */
    MMAGIC_IPERF_CMD_COMMIT = 3,
    /** Starts an iperf session using the current values in the the subsystem config. */
    MMAGIC_IPERF_CMD_RUN    = 8,
};

/** sys configuration command IDs */
enum mmagic_sys_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_SYS_CMD_GET         = 0,
    /** Set the value of a configuration variable */
    MMAGIC_SYS_CMD_SET         = 1,
    /** Reserved (unused) */
    MMAGIC_SYS_CMD_LOAD        = 2,
    /** Commit the current configuration to flash */
    MMAGIC_SYS_CMD_COMMIT      = 3,
    /** Performs a soft reset. */
    MMAGIC_SYS_CMD_RESET       = 8,
    /** Enters deep sleep mode. */
    MMAGIC_SYS_CMD_DEEP_SLEEP  = 9,
    /** Gets the device firmware and hardware versions. */
    MMAGIC_SYS_CMD_GET_VERSION = 10,
};

/** tcp configuration command IDs */
enum mmagic_tcp_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_TCP_CMD_GET        = 0,
    /** Set the value of a configuration variable */
    MMAGIC_TCP_CMD_SET        = 1,
    /** Reserved (unused) */
    MMAGIC_TCP_CMD_LOAD       = 2,
    /** Commit the current configuration to flash */
    MMAGIC_TCP_CMD_COMMIT     = 3,
    /** Opens a client TCP socket and returns its stream ID. */
    MMAGIC_TCP_CMD_CONNECT    = 8,
    /** Opens a server TCP socket and returns its stream ID. */
    MMAGIC_TCP_CMD_BIND       = 9,
    /** Reads from a socket. */
    MMAGIC_TCP_CMD_RECV       = 10,
    /** Writes to a socket. */
    MMAGIC_TCP_CMD_SEND       = 11,
    /** Polls the socket till it is ready for reading. */
    MMAGIC_TCP_CMD_READ_POLL  = 12,
    /** Polls the socket till it is ready for writing. */
    MMAGIC_TCP_CMD_WRITE_POLL = 13,
    /** Waits for an incoming socket connection and returns a new stream ID. */
    MMAGIC_TCP_CMD_ACCEPT     = 14,
    /** Closes and frees the socket. */
    MMAGIC_TCP_CMD_CLOSE      = 15,
};

/** tls configuration variable IDs */
enum mmagic_tls_var
{
    /** Root certificate authority certificate. Supported formats are PEM and DER. Must be null
     * terminated if in PEM format. */
    MMAGIC_TLS_VAR_ROOT_CA_CERTIFICATE = 0,
    /** Certificate to identify the client. Supported formats are PEM and DER. Must be null
     * terminated if in PEM format. */
    MMAGIC_TLS_VAR_CLIENT_CERTIFICATE  = 1,
    /** Client private key. Supported formats are PEM and DER. Must be null terminated if in PEM
     * format. */
    MMAGIC_TLS_VAR_CLIENT_PRIVATE_KEY  = 2,
};

/** tls configuration command IDs */
enum mmagic_tls_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_TLS_CMD_GET    = 0,
    /** Set the value of a configuration variable */
    MMAGIC_TLS_CMD_SET    = 1,
    /** Reserved (unused) */
    MMAGIC_TLS_CMD_LOAD   = 2,
    /** Commit the current configuration to flash */
    MMAGIC_TLS_CMD_COMMIT = 3,
};

/** ntp configuration variable IDs */
enum mmagic_ntp_var
{
    /** The hostname or IP of the NTP server. Defaults to "0.pool.ntp.org". */
    MMAGIC_NTP_VAR_SERVER = 0,
};

/** ntp configuration command IDs */
enum mmagic_ntp_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_NTP_CMD_GET      = 0,
    /** Set the value of a configuration variable */
    MMAGIC_NTP_CMD_SET      = 1,
    /** Reserved (unused) */
    MMAGIC_NTP_CMD_LOAD     = 2,
    /** Commit the current configuration to flash */
    MMAGIC_NTP_CMD_COMMIT   = 3,
    /** Synchronizes internal time using the NTP server. */
    MMAGIC_NTP_CMD_SYNC     = 8,
    /** Reads current internal time. */
    MMAGIC_NTP_CMD_GET_TIME = 9,
};

/** mqtt configuration command IDs */
enum mmagic_mqtt_cmd
{
    /** Retrieve the value of a configuration variable */
    MMAGIC_MQTT_CMD_GET         = 0,
    /** Set the value of a configuration variable */
    MMAGIC_MQTT_CMD_SET         = 1,
    /** Reserved (unused) */
    MMAGIC_MQTT_CMD_LOAD        = 2,
    /** Commit the current configuration to flash */
    MMAGIC_MQTT_CMD_COMMIT      = 3,
    /** Starts the MQTT agent. Automatically handles reconnects with a backoff timer and saves up to
     * 10 subscriptions across reconnects. Listen to "broker_connection" events for information
     * about the state of the connection to the broker. */
    MMAGIC_MQTT_CMD_START_AGENT = 8,
    /** Publishes a message on a topic. */
    MMAGIC_MQTT_CMD_PUBLISH     = 9,
    /** Subscribes to a topic. Messages will arrive in the "message_received" event. */
    MMAGIC_MQTT_CMD_SUBSCRIBE   = 10,
    /** Stops the MQTT agent. */
    MMAGIC_MQTT_CMD_STOP_AGENT  = 11,
};

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_WLAN Module wlan: Wireless LAN management.
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_WLAN_CONFIG wlan configuration variables
 * @{
 */

/**
 * Gets @c country_code setting for module @c wlan.
 *
 * Two character country code used to identify the regulatory domain.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_country_code to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_country_code(
    struct mmagic_controller *controller, struct struct_country_code *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c country_code setting for module @c wlan.
 *
 * Two character country code used to identify the regulatory domain.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_country_code to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_country_code(
    struct mmagic_controller *controller, struct struct_country_code *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_COUNTRY_CODE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c ssid setting for module @c wlan.
 *
 * SSID of the AP to connect to, can be 1-32 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c string32 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_ssid(
    struct mmagic_controller *controller, struct string32 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SSID, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SSID, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c ssid setting for module @c wlan.
 *
 * SSID of the AP to connect to, can be 1-32 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c string32 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_ssid(
    struct mmagic_controller *controller, const char *var)
{
    struct string32 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SSID, (uint8_t *)&var_val, sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SSID, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c password setting for module @c wlan.
 *
 * Password used when associating, 1-100 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c string100 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_password(
    struct mmagic_controller *controller, struct string100 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PASSWORD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PASSWORD, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c password setting for module @c wlan.
 *
 * Password used when associating, 1-100 characters long.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c string100 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_password(
    struct mmagic_controller *controller, const char *var)
{
    struct string100 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PASSWORD, (uint8_t *)&var_val, sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PASSWORD, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c security setting for module @c wlan.
 *
 * Security type to used when associating.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_security_type to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_security(
    struct mmagic_controller *controller, enum mmagic_security_type *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SECURITY, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SECURITY, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c security setting for module @c wlan.
 *
 * Security type to used when associating.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_security_type to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_security(
    struct mmagic_controller *controller, enum mmagic_security_type var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SECURITY, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SECURITY, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c raw_priority setting for module @c wlan.
 *
 * Priority to request if raw is supported by the AP. Valid priorities are 0-7. -1 disables RAW.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c int16_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_raw_priority(
    struct mmagic_controller *controller, int16_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c raw_priority setting for module @c wlan.
 *
 * Priority to request if raw is supported by the AP. Valid priorities are 0-7. -1 disables RAW.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c int16_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_raw_priority(
    struct mmagic_controller *controller, int16_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RAW_PRIORITY, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c bssid setting for module @c wlan.
 *
 * BSSID of the ap to associate to, all 0x00 for any.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_mac_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_bssid(
    struct mmagic_controller *controller, struct struct_mac_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_BSSID, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_BSSID, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c bssid setting for module @c wlan.
 *
 * BSSID of the ap to associate to, all 0x00 for any.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_mac_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_bssid(
    struct mmagic_controller *controller, struct struct_mac_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_BSSID, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_BSSID, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c pmf_mode setting for module @c wlan.
 *
 * Protected Management Frame mode to use (802.11w).
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_pmf_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_pmf_mode(
    struct mmagic_controller *controller, enum mmagic_pmf_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c pmf_mode setting for module @c wlan.
 *
 * Protected Management Frame mode to use (802.11w).
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_pmf_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_pmf_mode(
    struct mmagic_controller *controller, enum mmagic_pmf_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_PMF_MODE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c station_type setting for module @c wlan.
 *
 * S1G non-AP STA type.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_station_type to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_station_type(
    struct mmagic_controller *controller, enum mmagic_station_type *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c station_type setting for module @c wlan.
 *
 * S1G non-AP STA type.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_station_type to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_station_type(
    struct mmagic_controller *controller, enum mmagic_station_type var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STATION_TYPE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c rts_threshold setting for module @c wlan.
 *
 * The RTS threshold (in octets) to set, or 0 to disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_rts_threshold(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c rts_threshold setting for module @c wlan.
 *
 * The RTS threshold (in octets) to set, or 0 to disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_rts_threshold(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_RTS_THRESHOLD, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c sgi_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether SGI support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_sgi_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c sgi_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether SGI support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_sgi_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SGI_ENABLED, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c subbands_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether sub-band support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_subbands_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c subbands_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether sub-band support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_subbands_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_SUBBANDS_ENABLED, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c ampdu_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether AMPDU support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_ampdu_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c ampdu_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether AMPDU support should be enabled.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_ampdu_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_AMPDU_ENABLED, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c power_save_mode setting for module @c wlan.
 *
 * Sets the 802.11 power save mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_power_save_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_power_save_mode(
    struct mmagic_controller *controller, enum mmagic_power_save_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c power_save_mode setting for module @c wlan.
 *
 * Sets the 802.11 power save mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_power_save_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_power_save_mode(
    struct mmagic_controller *controller, enum mmagic_power_save_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_POWER_SAVE_MODE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c fragment_threshold setting for module @c wlan.
 *
 * Sets the 802.11 fragmentation threshold. The fragmentation threshold (in octets) to set, or 0 to
 * disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_fragment_threshold(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c fragment_threshold setting for module @c wlan.
 *
 * Sets the 802.11 fragmentation threshold. The fragmentation threshold (in octets) to set, or 0 to
 * disable.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_fragment_threshold(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_FRAGMENT_THRESHOLD, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c cac_enabled setting for module @c wlan.
 *
 * Whether Centralized Authentication Controlled is enabled on the STA.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_cac_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c cac_enabled setting for module @c wlan.
 *
 * Whether Centralized Authentication Controlled is enabled on the STA.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_cac_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_CAC_ENABLED, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c offload_arp_response setting for module @c wlan.
 *
 * If true, enables ARP response offload which allows the Morse chip to directly respond to ARP
 * requests without waking up the host processor.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_offload_arp_response(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, (uint8_t *)var,
                                  sizeof(*var), MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c offload_arp_response setting for module @c wlan.
 *
 * If true, enables ARP response offload which allows the Morse chip to directly respond to ARP
 * requests without waking up the host processor.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_offload_arp_response(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_RESPONSE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c offload_arp_refresh_s setting for module @c wlan.
 *
 * If non zero, enables ARP refresh offload with the specified interval in seconds. Note: ARP
 * response offload needs to be enabled for this feature to work.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_offload_arp_refresh_s(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, (uint8_t *)var,
                                  sizeof(*var), MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c offload_arp_refresh_s setting for module @c wlan.
 *
 * If non zero, enables ARP refresh offload with the specified interval in seconds. Note: ARP
 * response offload needs to be enabled for this feature to work.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_offload_arp_refresh_s(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_OFFLOAD_ARP_REFRESH_S, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c min_health_check_intvl_ms setting for module @c wlan.
 *
 * The minimum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then health checks will always happen at the max_interval_ms value.
 * min_interval_ms must always be less than or equal to max_interval_ms. If only
 * min_health_check_intvl_ms is specified, then max_health_check_intvl_ms is assumed to be
 * unbounded.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_min_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, (uint8_t *)var,
                                  sizeof(*var), MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c min_health_check_intvl_ms setting for module @c wlan.
 *
 * The minimum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then health checks will always happen at the max_interval_ms value.
 * min_interval_ms must always be less than or equal to max_interval_ms. If only
 * min_health_check_intvl_ms is specified, then max_health_check_intvl_ms is assumed to be
 * unbounded.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_min_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MIN_HEALTH_CHECK_INTVL_MS, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c max_health_check_intvl_ms setting for module @c wlan.
 *
 * The maximum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then periodic health checks will be disabled. min_interval_ms must always be less
 * than or equal to max_interval_ms. Set this to UINT32_MAX to have the maximum unbounded. If only
 * max_health_check_intvl_ms is specified, then min_health_check_intvl_ms is assumed to be 0.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_max_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, (uint8_t *)var,
                                  sizeof(*var), MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c max_health_check_intvl_ms setting for module @c wlan.
 *
 * The maximum interval to wait after the last health check before triggering another. If this
 * parameter is 0 then periodic health checks will be disabled. min_interval_ms must always be less
 * than or equal to max_interval_ms. Set this to UINT32_MAX to have the maximum unbounded. If only
 * max_health_check_intvl_ms is specified, then min_health_check_intvl_ms is assumed to be 0.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_max_health_check_intvl_ms(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MAX_HEALTH_CHECK_INTVL_MS, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c ndp_probe_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether NDP probe support should be enabled. Will only take effect after
 * a connect or scan command is sent.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_ndp_probe_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_NDP_PROBE_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_NDP_PROBE_ENABLED, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c ndp_probe_enabled setting for module @c wlan.
 *
 * Boolean value indicating whether NDP probe support should be enabled. Will only take effect after
 * a connect or scan command is sent.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_ndp_probe_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_NDP_PROBE_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_NDP_PROBE_ENABLED, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c sta_scan_interval_base_s setting for module @c wlan.
 *
 * The base scan interval (in seconds) to use when (re)connecting. See documentation of
 * mmwlan_sta_args.scan_interval_base_s for further details. Note that changes will only take effect
 * on invocation of wlan-connect.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint16_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_sta_scan_interval_base_s(
    struct mmagic_controller *controller, uint16_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_BASE_S, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_BASE_S, (uint8_t *)var,
                                  sizeof(*var), MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c sta_scan_interval_base_s setting for module @c wlan.
 *
 * The base scan interval (in seconds) to use when (re)connecting. See documentation of
 * mmwlan_sta_args.scan_interval_base_s for further details. Note that changes will only take effect
 * on invocation of wlan-connect.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint16_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_sta_scan_interval_base_s(
    struct mmagic_controller *controller, uint16_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_BASE_S, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_BASE_S, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c sta_scan_interval_limit_s setting for module @c wlan.
 *
 * The maximum interval between scan attempts when (re)connecting. See documentation of
 * mmwlan_sta_args.scan_interval_limit_s for further details. Note that changes will only take
 * effect on invocation of wlan-connect.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint16_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_sta_scan_interval_limit_s(
    struct mmagic_controller *controller, uint16_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_LIMIT_S, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_LIMIT_S, (uint8_t *)var,
                                  sizeof(*var), MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c sta_scan_interval_limit_s setting for module @c wlan.
 *
 * The maximum interval between scan attempts when (re)connecting. See documentation of
 * mmwlan_sta_args.scan_interval_limit_s for further details. Note that changes will only take
 * effect on invocation of wlan-connect.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint16_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_sta_scan_interval_limit_s(
    struct mmagic_controller *controller, uint16_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_LIMIT_S, (uint8_t *)&var,
                                  sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STA_SCAN_INTERVAL_LIMIT_S, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c qos_0_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 0 (AC_BE) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `3,15,1023,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c string32 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_qos_0_params(
    struct mmagic_controller *controller, struct string32 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_0_PARAMS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_0_PARAMS, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c qos_0_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 0 (AC_BE) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `3,15,1023,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c string32 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_qos_0_params(
    struct mmagic_controller *controller, const char *var)
{
    struct string32 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_0_PARAMS, (uint8_t *)&var_val,
                                  sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_0_PARAMS, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c qos_1_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 1 (AC_BK) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `7,15,1023,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c string32 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_qos_1_params(
    struct mmagic_controller *controller, struct string32 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_1_PARAMS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_1_PARAMS, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c qos_1_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 1 (AC_BK) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `7,15,1023,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c string32 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_qos_1_params(
    struct mmagic_controller *controller, const char *var)
{
    struct string32 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_1_PARAMS, (uint8_t *)&var_val,
                                  sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_1_PARAMS, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c qos_2_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 2 (AC_VI) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `2,7,15,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c string32 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_qos_2_params(
    struct mmagic_controller *controller, struct string32 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_2_PARAMS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_2_PARAMS, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c qos_2_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 2 (AC_VI) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `2,7,15,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c string32 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_qos_2_params(
    struct mmagic_controller *controller, const char *var)
{
    struct string32 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_2_PARAMS, (uint8_t *)&var_val,
                                  sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_2_PARAMS, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c qos_3_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 3 (AC_VO) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `2,3,7,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c string32 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_qos_3_params(
    struct mmagic_controller *controller, struct string32 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_3_PARAMS, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_QOS_3_PARAMS, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c qos_3_params setting for module @c wlan.
 *
 * The default QoS queue configuration for Access Category 3 (AC_VO) that is active while the
 * station is connecting to an Access Point. This is a string containing the following comma
 * separated integer values (in order): `aifs,cw_min,cw_max,txop_max_us`. For example:
 * `2,3,7,15008`. More information about the individual parameters can be found in the API
 * documentation for `mmwlan_qos_queue_params`.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c string32 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_qos_3_params(
    struct mmagic_controller *controller, const char *var)
{
    struct string32 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_3_PARAMS, (uint8_t *)&var_val,
                                  sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_QOS_3_PARAMS, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c mcs10_mode setting for module @c wlan.
 *
 * The currently configured MCS10 behavior. This only takes effect after calling the WLAN connect
 * command. This is an enum with 3 modes: disabled, which will never use MCS10, forced, which will
 * always use MCS10 instead of MCS0 if the bandwidth is 1 MHz, and auto, which will use MCS10 on
 * retries instead of MCS0 when the bandwidth is 1 MHz.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_mcs10_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_mcs10_mode(
    struct mmagic_controller *controller, enum mmagic_mcs10_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MCS10_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_MCS10_MODE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c mcs10_mode setting for module @c wlan.
 *
 * The currently configured MCS10 behavior. This only takes effect after calling the WLAN connect
 * command. This is an enum with 3 modes: disabled, which will never use MCS10, forced, which will
 * always use MCS10 instead of MCS0 if the bandwidth is 1 MHz, and auto, which will use MCS10 on
 * retries instead of MCS0 when the bandwidth is 1 MHz.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_mcs10_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_mcs10_mode(
    struct mmagic_controller *controller, enum mmagic_mcs10_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MCS10_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_MCS10_MODE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c sta_evt_en setting for module @c wlan.
 *
 * When set to true, STA event notifications will be provided. Setting this to false will suppress
 * these notifications. Defaults to false.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_sta_evt_en(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STA_EVT_EN, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_STA_EVT_EN, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c sta_evt_en setting for module @c wlan.
 *
 * When set to true, STA event notifications will be provided. Setting this to false will suppress
 * these notifications. Defaults to false.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_sta_evt_en(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STA_EVT_EN, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_STA_EVT_EN, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c duty_cycle_mode setting for module @c wlan.
 *
 * The duty cycle air time distribution mode. The duty cycle mode can be set to spread, where the
 * air time is spread evenly across the window; or burst, where air time is available to be consumed
 * immediately.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_duty_cycle_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_wlan_duty_cycle_mode(
    struct mmagic_controller *controller, enum mmagic_duty_cycle_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_DUTY_CYCLE_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET,
                                  MMAGIC_WLAN_VAR_DUTY_CYCLE_MODE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c duty_cycle_mode setting for module @c wlan.
 *
 * The duty cycle air time distribution mode. The duty cycle mode can be set to spread, where the
 * air time is spread evenly across the window; or burst, where air time is available to be consumed
 * immediately.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_duty_cycle_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_wlan_duty_cycle_mode(
    struct mmagic_controller *controller, enum mmagic_duty_cycle_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_DUTY_CYCLE_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SET,
                                  MMAGIC_WLAN_VAR_DUTY_CYCLE_MODE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_COMMIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_WLAN, MMAGIC_WLAN_CMD_COMMIT,
                                  0, NULL, 0, MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/** @} */

/** Command arguments structure for wlan_connect */
struct MM_PACKED mmagic_core_wlan_connect_cmd_args
{
    /** Duration in milliseconds to wait for connection establish, if connection does not get
     * established an explicit disconnect will be sent. 0 to return immediately without waiting. */
    uint32_t timeout;
};

/**
 * Brings up the WLAN interface and connects to the AP with configured parameters.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_connect(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_connect_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    /* Account for the timeout argument when waiting for the response and make sure no overflow. */
    if (UINT32_MAX - response_timeout_ms >= cmd_args->timeout)
    {
        response_timeout_ms += cmd_args->timeout;
    }
    else
    {
        response_timeout_ms = UINT32_MAX;
    }

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_CONNECT, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_CONNECT, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/**
 * Disconnects and brings down the WLAN interface.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_disconnect(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_DISCONNECT, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_DISCONNECT, 0,
                                NULL, 0, response_timeout_ms);
    return status;
}

/** Command arguments structure for wlan_scan */
struct MM_PACKED mmagic_core_wlan_scan_cmd_args
{
    /** Optional SSID to include in probe requests. */
    struct string32 ssid;
    /** Optional duration in milliseconds to wait for scan to complete, if scan does not complete by
     * the timeout any available results will be returned and the scan aborted. */
    uint32_t timeout;
};

/** Response arguments structure for wlan_scan */
struct MM_PACKED mmagic_core_wlan_scan_rsp_args
{
    /** Reference to structure to store the results of the scan. */
    struct struct_scan_status results;
};

/**
 * Starts an undirected scan for available networks.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_scan(struct mmagic_controller *controller,
                                                             struct mmagic_core_wlan_scan_cmd_args *
                                                             cmd_args,
                                                             struct mmagic_core_wlan_scan_rsp_args *
                                                             rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    /* Account for the timeout argument when waiting for the response and make sure no overflow. */
    if (UINT32_MAX - response_timeout_ms >= cmd_args->timeout)
    {
        response_timeout_ms += cmd_args->timeout;
    }
    else
    {
        response_timeout_ms = UINT32_MAX;
    }

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SCAN, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_SCAN, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Response arguments structure for wlan_get_rssi */
struct MM_PACKED mmagic_core_wlan_get_rssi_rsp_args
{
    /** The RSSI in dBm. */
    int32_t rssi;
};

/**
 * Retrieves the RSSI if the WLAN interface is up, else 0.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_get_rssi(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_get_rssi_rsp_args *rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_RSSI, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_RSSI, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Response arguments structure for wlan_get_mac_addr */
struct MM_PACKED mmagic_core_wlan_get_mac_addr_rsp_args
{
    /** Buffer to receive the MAC address. */
    struct struct_mac_addr mac_addr;
};

/**
 * Retrieves the MAC address if the WLAN interface is up.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_get_mac_addr(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_get_mac_addr_rsp_args *rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_MAC_ADDR,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_GET_MAC_ADDR,
                                  0, (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Command arguments structure for wlan_wnm_sleep */
struct MM_PACKED mmagic_core_wlan_wnm_sleep_cmd_args
{
    /** Boolean indicating whether WNM sleep is enabled. */
    bool wnm_sleep_enabled;
};

/**
 * Requests entry or exit from extended sleep (wnm sleep) if the WLAN interface is up.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_wnm_sleep(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_wnm_sleep_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_WNM_SLEEP, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_WNM_SLEEP, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/** Command arguments structure for wlan_beacon_monitor_enable */
struct MM_PACKED mmagic_core_wlan_beacon_monitor_enable_cmd_args
{
    /** OUIs to monitor. */
    struct struct_oui_list oui_filter;
};

/**
 * Enable beacon monitoring with the given filter settings. If beacon monitoring is already enabled
 * it will be reconfigured with the given arguments.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_beacon_monitor_enable(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_beacon_monitor_enable_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_BEACON_MONITOR_ENABLE, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_BEACON_MONITOR_ENABLE, 0, NULL, 0,
                                  response_timeout_ms);
    return status;
}

/**
 * Disable beacon monitoring. If beacon monitor is not enabled then this has no effect.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_beacon_monitor_disable(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_BEACON_MONITOR_DISABLE, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                MMAGIC_WLAN_CMD_BEACON_MONITOR_DISABLE, 0, NULL, 0,
                                response_timeout_ms);
    return status;
}

/**
 * This puts the Morse chip into standby mode allowing the host processor to go to sleep while the
 * Morse chip takes over certain functionality to keep the connection alive with the provision to
 * wake up the host processor when certain conditions are met.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_enter(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_ENTER,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_ENTER,
                                0, NULL, 0, response_timeout_ms);
    return status;
}

/**
 * Forces the Morse chip to exit standby mode. There may be certain instances such as a timer
 * expiry, which cause the host chip to wake up independant of the Morse chip. In such situations,
 * the host calls this function to instruct the Morse chip to exit standby mode and return to normal
 * operating mode.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_exit(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_EXIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN, MMAGIC_WLAN_CMD_STANDBY_EXIT, 0,
                                NULL, 0, response_timeout_ms);
    return status;
}

/** Command arguments structure for wlan_standby_set_status_payload */
struct MM_PACKED mmagic_core_wlan_standby_set_status_payload_cmd_args
{
    /** Payload to append to standby status packets. */
    struct struct_buffer64 payload;
};

/**
 * Sets the user payload for the standby status packet. Once standby mode is enabled, the Morse chip
 * will periodically emit a UDP standby status packet regardless of whether it is in standby or not.
 * The UDP packet will also be sent immediately upon entering or exiting Standby mode. If this
 * command is not executed then the standby status packet will contain no payload.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_set_status_payload(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_standby_set_status_payload_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_STATUS_PAYLOAD, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_STATUS_PAYLOAD, 0, NULL, 0,
                                  response_timeout_ms);
    return status;
}

/** Command arguments structure for wlan_standby_set_wake_filter */
struct MM_PACKED mmagic_core_wlan_standby_set_wake_filter_cmd_args
{
    /** Filter to apply to wake packets to wake on match. */
    struct struct_buffer64 filter;
    /** Offset within wake packet payload to apply the filter. */
    uint32_t offset;
};

/**
 * Configures the standby mode UDP wake packet filter. The system can be woken up from standby mode
 * by sending it a UDP wake packet. If a wake filter is set using this function then the wake packet
 * will only wake up the system if the specified filter pattern matches the payload at the specified
 * offset within the payload. If this command is not executed then any wake packet will wake up the
 * system.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_set_wake_filter(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_standby_set_wake_filter_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_WAKE_FILTER, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_WAKE_FILTER, 0, NULL, 0,
                                  response_timeout_ms);
    return status;
}

/** Command arguments structure for wlan_standby_set_config */
struct MM_PACKED mmagic_core_wlan_standby_set_config_cmd_args
{
    /** Interval in seconds for transmitting Standby status packets (Default 15s). */
    uint32_t notify_period_s;
    /** Source IP address to use for the standby status packets (Default 0.0.0.0). */
    struct struct_ip_addr src_ip;
    /** Destination IP address for the standby status packets (Default 0.0.0.0). */
    struct struct_ip_addr dst_ip;
    /** Destination UDP Port for the standby status packets, also used the source port for outgoing
     * UDP port for outgoing UDP packets (Default 22000). */
    uint16_t dst_port;
    /** Deprecated. This parameter is no longer used and will be removed in a future release. */
    uint32_t bss_inactivity_s;
    /** The interval in seconds to wake periodically from snooze mode and check for beacons. If no
     * beacons are found then the Morse chip will re-enter snooze mode. If beacons are found then
     * the Morse chip will exit standby mode so the host can reassociate (Default 60s). */
    uint32_t snooze_period_s;
    /** The amount in seconds to increase successive snooze intervals. This saves power by snoozing
     * for longer before checking for beacons again if no beacons are found. (Default 0s). */
    uint32_t snooze_increment_s;
    /** The maximum time in seconds to snooze for after increments (Default unlimited). */
    uint32_t snooze_max_s;
};

/**
 * Sets the standby mode configuration parameters. If this command is not executed then the defaults
 * are as specified.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_standby_set_config(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_standby_set_config_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_CONFIG, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_STANDBY_SET_CONFIG, 0, NULL, 0,
                                  response_timeout_ms);
    return status;
}

/** Response arguments structure for wlan_get_sta_status */
struct MM_PACKED mmagic_core_wlan_get_sta_status_rsp_args
{
    /** The current STA status. */
    enum mmagic_sta_state sta_status;
};

/**
 * Retrieves the STA status of the WLAN interface.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_wlan_get_sta_status(
    struct mmagic_controller *controller,
    struct
    mmagic_core_wlan_get_sta_status_rsp_args *rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_GET_STA_STATUS, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_WLAN,
                                  MMAGIC_WLAN_CMD_GET_STA_STATUS, 0, (uint8_t *)rsp_args,
                                  sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Event arguments structure for wlan_beacon_rx */
struct MM_PACKED mmagic_wlan_beacon_rx_event_args
{
    /** Raw octet string of Vendor Information Elements contained in the beacon. Only the IEs that
     * match the configured filters are returned. If multiple matching IEs are present then they are
     * concatenated in the buffer. Each IE is a TLV where the first byte is the Tag (0xDD for Vendor
     * Specific IE), followed by a byte specifying the length IE contents (i.e., excluding the Tag
     * and Length). */
    struct raw1536 vendor_ies;
};

/**
 * Handler for the wlan-beacon_rx event.
 *
 * Triggered when a beacon matching the configured beacon monitor filter(s) is received.
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param event_args Notication arguments received from the agent.
 * @param arg        Opaque argument that was provided when the callback was registered.
 */
typedef void (*mmagic_wlan_beacon_rx_event_handler_t)(
    const struct mmagic_wlan_beacon_rx_event_args *event_args, void *arg);

/**
 * Register a handler for the wlan-beacon_rx event.
 *
 * Triggered when a beacon matching the configured beacon monitor filter(s) is received.
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_wlan_beacon_rx_handler(
    struct mmagic_controller *controller,
    mmagic_wlan_beacon_rx_event_handler_t handler, void *arg);

/** Event arguments structure for wlan_standby_exit */
struct MM_PACKED mmagic_wlan_standby_exit_event_args
{
    /** Reason why we exited standby mode. If we manually exited standby mode through a call to
     * wlan-standby_exit, then the reason will be standby_exit_none. */
    enum mmagic_standby_mode_exit_reason reason;
};

/**
 * Handler for the wlan-standby_exit event.
 *
 * Triggered when chip exits standby mode either manually or through an event.
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param event_args Notication arguments received from the agent.
 * @param arg        Opaque argument that was provided when the callback was registered.
 */
typedef void (*mmagic_wlan_standby_exit_event_handler_t)(
    const struct mmagic_wlan_standby_exit_event_args *event_args, void *arg);

/**
 * Register a handler for the wlan-standby_exit event.
 *
 * Triggered when chip exits standby mode either manually or through an event.
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_wlan_standby_exit_handler(
    struct mmagic_controller *controller,
    mmagic_wlan_standby_exit_event_handler_t handler, void *arg);

/** Event arguments structure for wlan_sta_event */
struct MM_PACKED mmagic_wlan_sta_event_event_args
{
    /** The reported WLAN STA evt. */
    enum mmagic_sta_event event;
};

/**
 * Handler for the wlan-sta_event event.
 *
 * Triggered when STA event occurs when in STA mode.
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param event_args Notication arguments received from the agent.
 * @param arg        Opaque argument that was provided when the callback was registered.
 */
typedef void (*mmagic_wlan_sta_event_event_handler_t)(
    const struct mmagic_wlan_sta_event_event_args *event_args, void *arg);

/**
 * Register a handler for the wlan-sta_event event.
 *
 * Triggered when STA event occurs when in STA mode.
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_wlan_sta_event_handler(
    struct mmagic_controller *controller,
    mmagic_wlan_sta_event_event_handler_t handler, void *arg);

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_IP Module ip: IP Stack Management
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_IP_CONFIG ip configuration variables
 * @{
 */

/**
 * Gets @c ip_addr setting for module @c ip.
 *
 * IP address to use for a static network connection. This will take effect when the reload command
 * is successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_ip_addr(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_IP_ADDR, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_IP_ADDR, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c ip_addr setting for module @c ip.
 *
 * IP address to use for a static network connection. This will take effect when the reload command
 * is successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_ip_addr(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_IP_ADDR, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_IP_ADDR, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c netmask setting for module @c ip.
 *
 * Netmask to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_netmask(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_NETMASK, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_NETMASK, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c netmask setting for module @c ip.
 *
 * Netmask to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_netmask(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_NETMASK, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_NETMASK, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c gateway setting for module @c ip.
 *
 * Gateway to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_gateway(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_GATEWAY, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_GATEWAY, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c gateway setting for module @c ip.
 *
 * Gateway to use for a static network connection. This will take effect when the reload command is
 * successfully executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_gateway(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_GATEWAY, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_GATEWAY, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c dns_server0 setting for module @c ip.
 *
 * Primary DNS server IP address. If a value is specified this will override the primary DNS server
 * provided by DHCP (if any). Changes will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dns_server0(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c dns_server0 setting for module @c ip.
 *
 * Primary DNS server IP address. If a value is specified this will override the primary DNS server
 * provided by DHCP (if any). Changes will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dns_server0(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER0, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c dns_server1 setting for module @c ip.
 *
 * Secondary DNS server IP address. If a value is specified this will override the secondary DNS
 * server provided by DHCP (if any). Changes will take effect when the reload command is
 * successfully executed. Note that this option may be ignored by some IP stacks.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dns_server1(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c dns_server1 setting for module @c ip.
 *
 * Secondary DNS server IP address. If a value is specified this will override the secondary DNS
 * server provided by DHCP (if any). Changes will take effect when the reload command is
 * successfully executed. Note that this option may be ignored by some IP stacks.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dns_server1(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DNS_SERVER1, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c dhcp_enabled setting for module @c ip.
 *
 * True to enable DHCP for IP address configuration, or false to use the static configuration given
 * by ip_addr, netmask, and gateway. This will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dhcp_enabled(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c dhcp_enabled setting for module @c ip.
 *
 * True to enable DHCP for IP address configuration, or false to use the static configuration given
 * by ip_addr, netmask, and gateway. This will take effect when the reload command is successfully
 * executed.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dhcp_enabled(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_ENABLED, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c dhcp_offload setting for module @c ip.
 *
 * If true, enables DHCP offload which allows the Morse chip to directly handle DHCP discovery and
 * leases without waking up the host processor. Note: this comes into effect only if ip.dhcp_enabled
 * is also true.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_dhcp_offload(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c dhcp_offload setting for module @c ip.
 *
 * If true, enables DHCP offload which allows the Morse chip to directly handle DHCP discovery and
 * leases without waking up the host processor. Note: this comes into effect only if ip.dhcp_enabled
 * is also true.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_dhcp_offload(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_DHCP_OFFLOAD, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c link_status_evt_en setting for module @c ip.
 *
 * When set to true, IP link status notifications will be provided. Setting this to false will
 * suppress these notifications. Defaults to true.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c bool to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ip_link_status_evt_en(
    struct mmagic_controller *controller, bool *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_LINK_STATUS_EVT_EN, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_GET,
                                  MMAGIC_IP_VAR_LINK_STATUS_EVT_EN, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c link_status_evt_en setting for module @c ip.
 *
 * When set to true, IP link status notifications will be provided. Setting this to false will
 * suppress these notifications. Defaults to true.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c bool to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ip_link_status_evt_en(
    struct mmagic_controller *controller, bool var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_LINK_STATUS_EVT_EN, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_SET,
                                  MMAGIC_IP_VAR_LINK_STATUS_EVT_EN, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_ip_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_COMMIT, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IP, MMAGIC_IP_CMD_COMMIT, 0,
                                  NULL, 0, MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/** @} */

/** Response arguments structure for ip_status */
struct MM_PACKED mmagic_core_ip_status_rsp_args
{
    /** Reference to the struct to return the IP status retrieved from the network stack. */
    struct struct_ip_status status;
};

/**
 * Gets the status of the IP stack.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_status(struct mmagic_controller *controller,
                                                             struct mmagic_core_ip_status_rsp_args *
                                                             rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_STATUS, 0, NULL,
                                  0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_STATUS, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/**
 * Reloads the IP stack network configuration based on the current values in the subsystem config.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_reload(struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_RELOAD, 0, NULL,
                                  0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_IP, MMAGIC_IP_CMD_RELOAD, 0, NULL, 0,
                                response_timeout_ms);
    return status;
}

/** Command arguments structure for ip_enable_tcp_keepalive_offload */
struct MM_PACKED mmagic_core_ip_enable_tcp_keepalive_offload_cmd_args
{
    /** Interval in seconds to send the keep-alive packets in. */
    uint16_t period_s;
    /** The number of times to retry before giving up. */
    uint8_t retry_count;
    /** The interval in seconds to wait between retries. */
    uint8_t retry_interval_s;
};

/**
 * Enables sending periodic TCP keep-alive packets by the morse chip allowing the TCP connection to
 * be maintained without waking up the host processor. This needs to be enabled before opening a TCP
 * connection. As of now, this feature will work only on the first TCP connection opened after this
 * command.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_enable_tcp_keepalive_offload(
    struct mmagic_controller *controller,
    struct
    mmagic_core_ip_enable_tcp_keepalive_offload_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_ENABLE_TCP_KEEPALIVE_OFFLOAD, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_ENABLE_TCP_KEEPALIVE_OFFLOAD, 0, NULL, 0,
                                  response_timeout_ms);
    return status;
}

/**
 * Disables sending of TCP keepalive packets.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_disable_tcp_keepalive_offload(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_DISABLE_TCP_KEEPALIVE_OFFLOAD, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                MMAGIC_IP_CMD_DISABLE_TCP_KEEPALIVE_OFFLOAD, 0, NULL, 0,
                                response_timeout_ms);
    return status;
}

/** Command arguments structure for ip_set_whitelist_filter */
struct MM_PACKED mmagic_core_ip_set_whitelist_filter_cmd_args
{
    /** The IPv4 source address to match, 0.0.0.0 for any. */
    struct struct_ip_addr src_ip;
    /** The IPv4 destination address to match, 0.0.0.0 for any (Usually our IP address). */
    struct struct_ip_addr dest_ip;
    /** The netmask to apply to the source or destination IP, 0.0.0.0 for any. */
    struct struct_ip_addr netmask;
    /** The source port to match, 0 for any. */
    uint16_t src_port;
    /** The destination port to match, 0 for any. */
    uint16_t dest_port;
    /** The IPv4 protocol number to match - 6 for TCP, 17 for UDP, 0 for any. */
    uint8_t ip_protocol;
    /** The LLC protocol (or EtherType) to match - 0x0800 for IPv4 and 0x86DD for IPv6, 0 for any.
     */
    uint16_t llc_protocol;
};

/**
 * Sets the whitelist filter specifing which incoming packets can wake the system from standby mode.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_set_whitelist_filter(
    struct mmagic_controller *controller,
    struct
    mmagic_core_ip_set_whitelist_filter_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_SET_WHITELIST_FILTER, 0, (uint8_t *)cmd_args,
                                  sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_SET_WHITELIST_FILTER, 0, NULL, 0,
                                  response_timeout_ms);
    return status;
}

/**
 * Clears any applied whitelist filters.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ip_clear_whitelist_filter(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IP,
                                  MMAGIC_IP_CMD_CLEAR_WHITELIST_FILTER, 0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_IP,
                                MMAGIC_IP_CMD_CLEAR_WHITELIST_FILTER, 0, NULL, 0,
                                response_timeout_ms);
    return status;
}

/** Event arguments structure for ip_link_status */
struct MM_PACKED mmagic_ip_link_status_event_args
{
    /** Link status for the WLAN interface. This is only valid when the WLAN interface is configured
     * to be a STA rather than an AP. */
    struct struct_ip_status ip_link_status;
};

/**
 * Handler for the ip-link_status event.
 *
 * Triggered when the IP stack has a valid address.
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param event_args Notication arguments received from the agent.
 * @param arg        Opaque argument that was provided when the callback was registered.
 */
typedef void (*mmagic_ip_link_status_event_handler_t)(
    const struct mmagic_ip_link_status_event_args *event_args, void *arg);

/**
 * Register a handler for the ip-link_status event.
 *
 * Triggered when the IP stack has a valid address.
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_ip_link_status_handler(
    struct mmagic_controller *controller,
    mmagic_ip_link_status_event_handler_t handler, void *arg);

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_PING Module ping: Ping application.
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_PING_CONFIG ping configuration variables
 * @{
 */

/**
 * Gets @c target setting for module @c ping.
 *
 * The IP address of the ping target.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ping_target(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_TARGET, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_TARGET, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c target setting for module @c ping.
 *
 * The IP address of the ping target.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ping_target(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_TARGET, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_TARGET, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c interval setting for module @c ping.
 *
 * The time interval between ping requests (in milliseconds).
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ping_interval(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_INTERVAL, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_INTERVAL, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c interval setting for module @c ping.
 *
 * The time interval between ping requests (in milliseconds).
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ping_interval(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_INTERVAL, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_INTERVAL, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c count setting for module @c ping.
 *
 * This specifies the number of ping requests to send before terminating the session. If this is
 * zero or exceeds UINT16_MAX (65535) then it it will be set to UINT16_MAX.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ping_count(
    struct mmagic_controller *controller, uint32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_COUNT, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_GET,
                                  MMAGIC_PING_VAR_COUNT, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c count setting for module @c ping.
 *
 * This specifies the number of ping requests to send before terminating the session. If this is
 * zero or exceeds UINT16_MAX (65535) then it it will be set to UINT16_MAX.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ping_count(
    struct mmagic_controller *controller, uint32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_COUNT, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_SET,
                                  MMAGIC_PING_VAR_COUNT, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_ping_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_COMMIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_PING, MMAGIC_PING_CMD_COMMIT,
                                  0, NULL, 0, MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/** @} */

/** Response arguments structure for ping_run */
struct MM_PACKED mmagic_core_ping_run_rsp_args
{
    /** Reference to the struct to return the status of the ping session. */
    struct struct_ping_status status;
};

/**
 * Commences a ping session using the current values in the the subsystem config.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ping_run(struct mmagic_controller *controller,
                                                            struct mmagic_core_ping_run_rsp_args *
                                                            rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_PING, MMAGIC_PING_CMD_RUN, 0, NULL,
                                  0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_PING, MMAGIC_PING_CMD_RUN, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_IPERF Module iperf: Iperf application.
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_IPERF_CONFIG iperf configuration variables
 * @{
 */

/**
 * Gets @c mode setting for module @c iperf.
 *
 * The iperf mode to use. Valid values are udp_server, tcp_server, udp_client and tcp_client. If not
 * set, defaults to udp_server.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c enum_iperf_mode to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_mode(
    struct mmagic_controller *controller, enum mmagic_iperf_mode *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_MODE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_MODE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c mode setting for module @c iperf.
 *
 * The iperf mode to use. Valid values are udp_server, tcp_server, udp_client and tcp_client. If not
 * set, defaults to udp_server.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c enum_iperf_mode to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_mode(
    struct mmagic_controller *controller, enum mmagic_iperf_mode var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_MODE, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_MODE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c server setting for module @c iperf.
 *
 * IP address of server to connect to when in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_server(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_SERVER, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_SERVER, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c server setting for module @c iperf.
 *
 * IP address of server to connect to when in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c struct_ip_addr to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_server(
    struct mmagic_controller *controller, struct struct_ip_addr *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_SERVER, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_SERVER, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c port setting for module @c iperf.
 *
 * Specifies the local port to listen on when in server mode or the server port to send data to when
 * in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c uint16_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_port(
    struct mmagic_controller *controller, uint16_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_PORT, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_PORT, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c port setting for module @c iperf.
 *
 * Specifies the local port to listen on when in server mode or the server port to send data to when
 * in client mode.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c uint16_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_port(
    struct mmagic_controller *controller, uint16_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_PORT, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_PORT, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c amount setting for module @c iperf.
 *
 * This specifies the duration for client transfers specified either in seconds or bytes. If this is
 * negative, it specifies a time in seconds; if positive, it specifies the number of bytes to
 * transmit.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c int32_t to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_iperf_amount(
    struct mmagic_controller *controller, int32_t *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_AMOUNT, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_GET,
                                  MMAGIC_IPERF_VAR_AMOUNT, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c amount setting for module @c iperf.
 *
 * This specifies the duration for client transfers specified either in seconds or bytes. If this is
 * negative, it specifies a time in seconds; if positive, it specifies the number of bytes to
 * transmit.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c int32_t to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_iperf_amount(
    struct mmagic_controller *controller, int32_t var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_AMOUNT, (uint8_t *)&var, sizeof(var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_SET,
                                  MMAGIC_IPERF_VAR_AMOUNT, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_iperf_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_COMMIT,
                                  0, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_IPERF, MMAGIC_IPERF_CMD_COMMIT,
                                  0, NULL, 0, MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/** @} */

/** Response arguments structure for iperf_run */
struct MM_PACKED mmagic_core_iperf_run_rsp_args
{
    /** Reference to the struct to return the status of the iperf session. */
    struct struct_iperf_status status;
};

/**
 * Starts an iperf session using the current values in the the subsystem config.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_iperf_run(struct mmagic_controller *controller,
                                                             struct mmagic_core_iperf_run_rsp_args *
                                                             rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_IPERF, MMAGIC_IPERF_CMD_RUN, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_IPERF, MMAGIC_IPERF_CMD_RUN, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_SYS Module sys: System management.
 * @{
 */

/**
 * Performs a soft reset.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_sys_reset(struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    status = mmagic_controller_tx(controller, stream_id, MMAGIC_SYS,
                                  MMAGIC_SYS_CMD_RESET, 0, NULL, 0);
    return status;
}

/** Command arguments structure for sys_deep_sleep */
struct MM_PACKED mmagic_core_sys_deep_sleep_cmd_args
{
    /** Deep sleep mode to enter. */
    enum mmagic_deep_sleep_mode mode;
};

/**
 * Enters deep sleep mode.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_sys_deep_sleep(
    struct mmagic_controller *controller,
    struct
    mmagic_core_sys_deep_sleep_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_DEEP_SLEEP, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_DEEP_SLEEP, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/** Response arguments structure for sys_get_version */
struct MM_PACKED mmagic_core_sys_get_version_rsp_args
{
    /** Reference to structure to store the version information. */
    struct struct_version_info results;
};

/**
 * Gets the device firmware and hardware versions.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_sys_get_version(
    struct mmagic_controller *controller,
    struct
    mmagic_core_sys_get_version_rsp_args *rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_GET_VERSION, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_SYS, MMAGIC_SYS_CMD_GET_VERSION, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_TCP Module tcp: TCP Socket IO, supports secure connections using TLS.
 * @{
 */

/** Command arguments structure for tcp_connect */
struct MM_PACKED mmagic_core_tcp_connect_cmd_args
{
    /** URL of the server to connect to. */
    struct string254 url;
    /** TCP port to connect to. */
    uint16_t port;
    /** Enables TLS. Configure certificates through the TLS module. */
    bool enable_tls;
};

/** Response arguments structure for tcp_connect */
struct MM_PACKED mmagic_core_tcp_connect_rsp_args
{
    /** Stream ID of the opened socket. */
    uint8_t stream_id;
};

/**
 * Opens a client TCP socket and returns its stream ID.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_connect(struct mmagic_controller *controller,
                                                               struct
                                                               mmagic_core_tcp_connect_cmd_args *
                                                               cmd_args,
                                                               struct
                                                               mmagic_core_tcp_connect_rsp_args *
                                                               rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = 15000;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CONNECT, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CONNECT, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Command arguments structure for tcp_bind */
struct MM_PACKED mmagic_core_tcp_bind_cmd_args
{
    /** TCP port to listen on. */
    uint16_t port;
};

/** Response arguments structure for tcp_bind */
struct MM_PACKED mmagic_core_tcp_bind_rsp_args
{
    /** Stream ID of the opened socket. */
    uint8_t stream_id;
};

/**
 * Opens a server TCP socket and returns its stream ID.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_bind(struct mmagic_controller *controller,
                                                            struct mmagic_core_tcp_bind_cmd_args *
                                                            cmd_args,
                                                            struct mmagic_core_tcp_bind_rsp_args *
                                                            rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_BIND, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_BIND, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Command arguments structure for tcp_recv */
struct MM_PACKED mmagic_core_tcp_recv_cmd_args
{
    /** Stream ID of the socket to receive from. */
    uint8_t stream_id;
    /** TCP port to listen on. */
    uint16_t len;
    /** Timeout in ms. 0 to return immediately, UINT32_MAX to wait indefinately. */
    uint32_t timeout;
};

/** Response arguments structure for tcp_recv */
struct MM_PACKED mmagic_core_tcp_recv_rsp_args
{
    /** Buffer of read data. */
    struct raw1536 buffer;
};

/**
 * Reads from a socket.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_recv(struct mmagic_controller *controller,
                                                            struct mmagic_core_tcp_recv_cmd_args *
                                                            cmd_args,
                                                            struct mmagic_core_tcp_recv_rsp_args *
                                                            rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = cmd_args->stream_id;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    /* Account for the timeout argument when waiting for the response and make sure no overflow. */
    if (UINT32_MAX - response_timeout_ms >= cmd_args->timeout)
    {
        response_timeout_ms += cmd_args->timeout;
    }
    else
    {
        response_timeout_ms = UINT32_MAX;
    }

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_RECV, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_RECV, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Command arguments structure for tcp_send */
struct MM_PACKED mmagic_core_tcp_send_cmd_args
{
    /** Stream ID of the socket to send on. */
    uint8_t stream_id;
    /** Buffer to send. */
    struct raw1536 buffer;
};

/**
 * Writes to a socket.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_send(struct mmagic_controller *controller,
                                                            struct mmagic_core_tcp_send_cmd_args *
                                                            cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = cmd_args->stream_id;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_SEND, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_SEND, 0, NULL,
                                  0, response_timeout_ms);
    return status;
}

/** Command arguments structure for tcp_read_poll */
struct MM_PACKED mmagic_core_tcp_read_poll_cmd_args
{
    /** Stream ID of the socket to wait on. */
    uint8_t stream_id;
    /** Timeout in ms. 0 to return immediately, UINT32_MAX to wait indefinately. */
    uint32_t timeout;
};

/**
 * Polls the socket till it is ready for reading.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_read_poll(
    struct mmagic_controller *controller,
    struct
    mmagic_core_tcp_read_poll_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = cmd_args->stream_id;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    /* Account for the timeout argument when waiting for the response and make sure no overflow. */
    if (UINT32_MAX - response_timeout_ms >= cmd_args->timeout)
    {
        response_timeout_ms += cmd_args->timeout;
    }
    else
    {
        response_timeout_ms = UINT32_MAX;
    }

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_READ_POLL, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_READ_POLL, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/** Command arguments structure for tcp_write_poll */
struct MM_PACKED mmagic_core_tcp_write_poll_cmd_args
{
    /** Stream ID of the socket to wait on. */
    uint8_t stream_id;
    /** Timeout in ms. 0 to return immediately, UINT32_MAX to wait indefinately. */
    uint32_t timeout;
};

/**
 * Polls the socket till it is ready for writing.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_write_poll(
    struct mmagic_controller *controller,
    struct
    mmagic_core_tcp_write_poll_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = cmd_args->stream_id;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    /* Account for the timeout argument when waiting for the response and make sure no overflow. */
    if (UINT32_MAX - response_timeout_ms >= cmd_args->timeout)
    {
        response_timeout_ms += cmd_args->timeout;
    }
    else
    {
        response_timeout_ms = UINT32_MAX;
    }

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_WRITE_POLL, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_WRITE_POLL, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/** Command arguments structure for tcp_accept */
struct MM_PACKED mmagic_core_tcp_accept_cmd_args
{
    /** Stream ID of the bound socket. */
    uint8_t stream_id;
};

/** Response arguments structure for tcp_accept */
struct MM_PACKED mmagic_core_tcp_accept_rsp_args
{
    /** Stream ID of the new incoming connection. */
    uint8_t stream_id;
};

/**
 * Waits for an incoming socket connection and returns a new stream ID.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_accept(struct mmagic_controller *controller,
                                                              struct mmagic_core_tcp_accept_cmd_args
                                                              *cmd_args,
                                                              struct mmagic_core_tcp_accept_rsp_args
                                                              *rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = cmd_args->stream_id;
    uint32_t response_timeout_ms = -1;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_ACCEPT, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_ACCEPT, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Command arguments structure for tcp_close */
struct MM_PACKED mmagic_core_tcp_close_cmd_args
{
    /** Stream ID of the socket to close. */
    uint8_t stream_id;
};

/**
 * Closes and frees the socket.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_tcp_close(struct mmagic_controller *controller,
                                                             struct mmagic_core_tcp_close_cmd_args *
                                                             cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CLOSE, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_TCP, MMAGIC_TCP_CMD_CLOSE, 0, NULL,
                                  0, response_timeout_ms);
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_TLS Module tls: TLS support.
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_TLS_CONFIG tls configuration variables
 * @{
 */

/**
 * Gets @c root_ca_certificate setting for module @c tls.
 *
 * Root certificate authority certificate. Supported formats are PEM and DER. Must be null
 * terminated if in PEM format.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c raw1536 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_tls_root_ca_certificate(
    struct mmagic_controller *controller, struct raw1536 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_GET,
                                  MMAGIC_TLS_VAR_ROOT_CA_CERTIFICATE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_GET,
                                  MMAGIC_TLS_VAR_ROOT_CA_CERTIFICATE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c root_ca_certificate setting for module @c tls.
 *
 * Root certificate authority certificate. Supported formats are PEM and DER. Must be null
 * terminated if in PEM format.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c raw1536 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_tls_root_ca_certificate(
    struct mmagic_controller *controller, struct raw1536 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_SET,
                                  MMAGIC_TLS_VAR_ROOT_CA_CERTIFICATE, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_SET,
                                  MMAGIC_TLS_VAR_ROOT_CA_CERTIFICATE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c client_certificate setting for module @c tls.
 *
 * Certificate to identify the client. Supported formats are PEM and DER. Must be null terminated if
 * in PEM format.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c raw1536 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_tls_client_certificate(
    struct mmagic_controller *controller, struct raw1536 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_GET,
                                  MMAGIC_TLS_VAR_CLIENT_CERTIFICATE, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_GET,
                                  MMAGIC_TLS_VAR_CLIENT_CERTIFICATE, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c client_certificate setting for module @c tls.
 *
 * Certificate to identify the client. Supported formats are PEM and DER. Must be null terminated if
 * in PEM format.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c raw1536 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_tls_client_certificate(
    struct mmagic_controller *controller, struct raw1536 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_SET,
                                  MMAGIC_TLS_VAR_CLIENT_CERTIFICATE, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_SET,
                                  MMAGIC_TLS_VAR_CLIENT_CERTIFICATE, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Gets @c client_private_key setting for module @c tls.
 *
 * Client private key. Supported formats are PEM and DER. Must be null terminated if in PEM format.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c raw1536 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_tls_client_private_key(
    struct mmagic_controller *controller, struct raw1536 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_GET,
                                  MMAGIC_TLS_VAR_CLIENT_PRIVATE_KEY, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_GET,
                                  MMAGIC_TLS_VAR_CLIENT_PRIVATE_KEY, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c client_private_key setting for module @c tls.
 *
 * Client private key. Supported formats are PEM and DER. Must be null terminated if in PEM format.
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c raw1536 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_tls_client_private_key(
    struct mmagic_controller *controller, struct raw1536 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_SET,
                                  MMAGIC_TLS_VAR_CLIENT_PRIVATE_KEY, (uint8_t *)var, sizeof(*var));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_SET,
                                  MMAGIC_TLS_VAR_CLIENT_PRIVATE_KEY, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_tls_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_COMMIT, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_TLS, MMAGIC_TLS_CMD_COMMIT, 0,
                                  NULL, 0, MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/** @} */

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_NTP Module ntp: Network Time Protocol.
 * @{
 */

/**
 * @defgroup MMAGIC_CONTROLLER_NTP_CONFIG ntp configuration variables
 * @{
 */

/**
 * Gets @c server setting for module @c ntp.
 *
 * The hostname or IP of the NTP server. Defaults to "0.pool.ntp.org".
 *
 * @param  controller Reference to the controller handle.
 * @param  var        Reference to the @c string254 to place the received data in.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_get_ntp_server(
    struct mmagic_controller *controller, struct string254 *var)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_NTP, MMAGIC_NTP_CMD_GET,
                                  MMAGIC_NTP_VAR_SERVER, NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_NTP, MMAGIC_NTP_CMD_GET,
                                  MMAGIC_NTP_VAR_SERVER, (uint8_t *)var, sizeof(*var),
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Sets @c server setting for module @c ntp.
 *
 * The hostname or IP of the NTP server. Defaults to "0.pool.ntp.org".
 *
 * @param  controller Reference to the controller handle.
 * @param  var        The @c string254 to write.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_set_ntp_server(
    struct mmagic_controller *controller, const char *var)
{
    struct string254 var_val;
    enum mmagic_status status;
    var_val.len = strlen(var);
    if (var_val.len > sizeof(var_val.data) - 1)
    {
        return MMAGIC_STATUS_INVALID_ARG;
    }
    memcpy(var_val.data, (const uint8_t *)var, var_val.len);
    memset(var_val.data + var_val.len, 0, sizeof(var_val.data) - var_val.len);
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_NTP, MMAGIC_NTP_CMD_SET,
                                  MMAGIC_NTP_VAR_SERVER, (uint8_t *)&var_val, sizeof(var_val));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_NTP, MMAGIC_NTP_CMD_SET,
                                  MMAGIC_NTP_VAR_SERVER, NULL, 0,
                                  MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/**
 * Saves all settings from persistent store.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            MMAGIC_STATUS_OK on success, else an error code.
 */
static inline enum mmagic_status mmagic_controller_ntp_commit_all(
    struct mmagic_controller *controller)
{
    enum mmagic_status status;
    status = mmagic_controller_tx(controller, CONTROL_STREAM, MMAGIC_NTP, MMAGIC_NTP_CMD_COMMIT, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, CONTROL_STREAM, MMAGIC_NTP, MMAGIC_NTP_CMD_COMMIT, 0,
                                  NULL, 0, MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS);
    return status;
}

/** @} */

/**
 * Synchronizes internal time using the NTP server.
 *
 * @param  controller Reference to the controller handle.
 *
 * @return            @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ntp_sync(struct mmagic_controller *controller)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_NTP, MMAGIC_NTP_CMD_SYNC, 0, NULL,
                                  0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    return mmagic_controller_rx(controller, stream_id, MMAGIC_NTP, MMAGIC_NTP_CMD_SYNC, 0, NULL, 0,
                                response_timeout_ms);
    return status;
}

/** Response arguments structure for ntp_get_time */
struct MM_PACKED mmagic_core_ntp_get_time_rsp_args
{
    /** Current internal time (Seconds since epoch, UTC). */
    uint64_t timestamp;
};

/**
 * Reads current internal time.
 *
 * @param      controller Reference to the controller handle.
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_ntp_get_time(
    struct mmagic_controller *controller,
    struct
    mmagic_core_ntp_get_time_rsp_args *rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_NTP, MMAGIC_NTP_CMD_GET_TIME, 0,
                                  NULL, 0);
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_NTP, MMAGIC_NTP_CMD_GET_TIME, 0,
                                  (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** @} */

/**
 * @defgroup MMAGIC_CONTROLLER_MQTT Module mqtt: MQTT agent.
 * @{
 */

/** Command arguments structure for mqtt_start_agent */
struct MM_PACKED mmagic_core_mqtt_start_agent_cmd_args
{
    /** URL of the broker to connect to. */
    struct string254 url;
    /** Port of the broker to connect to. */
    uint16_t port;
    /** Username to connect to the broker. */
    struct string100 username;
    /** Password to connect to the broker. */
    struct string100 password;
    /** Enables TLS for brokers that require it. Configure certificates through the TLS module. */
    bool secure;
};

/** Response arguments structure for mqtt_start_agent */
struct MM_PACKED mmagic_core_mqtt_start_agent_rsp_args
{
    /** Stream ID of the opened socket. */
    uint8_t stream_id;
};

/**
 * Starts the MQTT agent. Automatically handles reconnects with a backoff timer and saves up to 10
 * subscriptions across reconnects. Listen to "broker_connection" events for information about the
 * state of the connection to the broker.
 *
 * @param      controller Reference to the controller handle.
 * @param[in]  cmd_args   Command arguments
 * @param[out] rsp_args   Pointer to the data structure to be filled out with the result. If the
 *                          If the return code is not @ref MMAGIC_STATUS_OK then the
 *                          contents of this structure will be undefined.
 *
 * @return                @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_mqtt_start_agent(
    struct mmagic_controller *controller,
    struct
    mmagic_core_mqtt_start_agent_cmd_args *cmd_args,
    struct
    mmagic_core_mqtt_start_agent_rsp_args *rsp_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_START_AGENT,
                                  0, (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_START_AGENT,
                                  0, (uint8_t *)rsp_args, sizeof(*rsp_args), response_timeout_ms);
    return status;
}

/** Command arguments structure for mqtt_publish */
struct MM_PACKED mmagic_core_mqtt_publish_cmd_args
{
    /** Stream ID of the MQTT connection. */
    uint8_t stream_id;
    /** MQTT topic to publish to. */
    struct string254 topic;
    /** Contents of the message. */
    struct raw1536 payload;
    /** MQTT quality of service (0-2). Only 0 is supported for now. */
    uint8_t qos;
};

/**
 * Publishes a message on a topic.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_mqtt_publish(
    struct mmagic_controller *controller,
    struct
    mmagic_core_mqtt_publish_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_PUBLISH, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_PUBLISH, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/** Command arguments structure for mqtt_subscribe */
struct MM_PACKED mmagic_core_mqtt_subscribe_cmd_args
{
    /** Stream ID of the MQTT connection. */
    uint8_t stream_id;
    /** MQTT topic to subscribe to. */
    struct string254 topic;
    /** MQTT quality of service (0-2). Only 0 is supported for now. */
    uint8_t qos;
};

/**
 * Subscribes to a topic. Messages will arrive in the "message_received" event.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_mqtt_subscribe(
    struct mmagic_controller *controller,
    struct
    mmagic_core_mqtt_subscribe_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_SUBSCRIBE, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_SUBSCRIBE, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/** Command arguments structure for mqtt_stop_agent */
struct MM_PACKED mmagic_core_mqtt_stop_agent_cmd_args
{
    /** Stream ID of the MQTT connection. */
    uint8_t stream_id;
};

/**
 * Stops the MQTT agent.
 *
 * @param     controller Reference to the controller handle.
 * @param[in] cmd_args   Command arguments
 *
 * @return               @ref MMAGIC_STATUS_OK else an appropriate error code.
 */
static inline enum mmagic_status mmagic_controller_mqtt_stop_agent(
    struct mmagic_controller *controller,
    struct
    mmagic_core_mqtt_stop_agent_cmd_args *cmd_args)
{
    enum mmagic_status status;
    const uint8_t stream_id = CONTROL_STREAM;
    uint32_t response_timeout_ms = MMAGIC_CONTROLLER_DEFAULT_RESPONSE_TIMEOUT_MS;

    status = mmagic_controller_tx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_STOP_AGENT, 0,
                                  (uint8_t *)cmd_args, sizeof(*cmd_args));
    if (status != MMAGIC_STATUS_OK)
    {
        return status;
    }
    status = mmagic_controller_rx(controller, stream_id, MMAGIC_MQTT, MMAGIC_MQTT_CMD_STOP_AGENT, 0,
                                  NULL, 0, response_timeout_ms);
    return status;
}

/** Event arguments structure for mqtt_message_received */
struct MM_PACKED mmagic_mqtt_message_received_event_args
{
    /** Stream ID of the MQTT connection. */
    uint8_t stream_id;
    /** MQTT topic the message was received on. */
    struct string254 topic;
    /** Contents of the message. */
    struct raw1536 payload;
};

/**
 * Handler for the mqtt-message_received event.
 *
 * Triggered when a message is received on a topic that has been subscribed to.
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param event_args Notication arguments received from the agent.
 * @param arg        Opaque argument that was provided when the callback was registered.
 */
typedef void (*mmagic_mqtt_message_received_event_handler_t)(
    const struct mmagic_mqtt_message_received_event_args *event_args, void *arg);

/**
 * Register a handler for the mqtt-message_received event.
 *
 * Triggered when a message is received on a topic that has been subscribed to.
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_mqtt_message_received_handler(
    struct mmagic_controller *controller,
    mmagic_mqtt_message_received_event_handler_t handler, void *arg);

/** Event arguments structure for mqtt_broker_connection */
struct MM_PACKED mmagic_mqtt_broker_connection_event_args
{
    /** Stream ID of the MQTT connection. */
    uint8_t stream_id;
    /** Current state of the connection to the broker. */
    enum mmagic_status connection_state;
};

/**
 * Handler for the mqtt-broker_connection event.
 *
 * State of the connection to the broker (see mqtt-start).
 *
 * @note This function will be invoked in the context of the controller data link thread
 *       and should perform minimal processing.
 *
 * @warning This function must not invoke any mmagic API functions.
 *
 * @param event_args Notication arguments received from the agent.
 * @param arg        Opaque argument that was provided when the callback was registered.
 */
typedef void (*mmagic_mqtt_broker_connection_event_handler_t)(
    const struct mmagic_mqtt_broker_connection_event_args *event_args, void *arg);

/**
 * Register a handler for the mqtt-broker_connection event.
 *
 * State of the connection to the broker (see mqtt-start).
 *
 * @note The handler callbacks will be invoked in the context of the controller data link
 *       thread. The handler should perform minimal processing.
 *
 * @warning The handler callback must not invoke any mmagic API functions.
 *
 * @param controller Reference to the the controller handle.
 * @param handler    The handler function to register.
 * @param arg        Opaque argument to be passed to the handler when it is invoked.
 */
void mmagic_controller_register_mqtt_broker_connection_handler(
    struct mmagic_controller *controller,
    mmagic_mqtt_broker_connection_event_handler_t handler, void *arg);

/** @} */

#ifdef __cplusplus
}
#endif

/** @} */
